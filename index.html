<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> LightDust</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">LightDust</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
        <img
          src="/images/ayer.svg"
          class="cover-logo"
          alt="LightDust"
        />
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['不要忘记，我不会是个笑话', '万般过去亦无味，但有领会留下', '没有伤春的我看一看枯叶伴晚秋'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/vultr.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ad_2.jpg" width="300" alt="云服务器全球购低至2折">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-计算机网络相关知识点"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"
    >计算机网络-相关题目</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time datetime="2023-09-18T08:35:00.000Z" itemprop="datePublished">2023-09-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>​        这是笔者在学习《计算机网络-自顶向下方法》中搜集到的一系列常见问题。</p>
<p>​        部分题目与答案来自网络。欢迎大家提出意见。</p>
<h2 id="第一章概述"><a href="#第一章概述" class="headerlink" title="第一章概述"></a>第一章概述</h2><h3 id="1-1-协议和服务之间的联系和区别"><a href="#1-1-协议和服务之间的联系和区别" class="headerlink" title="1.1 协议和服务之间的联系和区别"></a>1.1 协议和服务之间的联系和区别</h3><p>（1）首先，协议是对等层实体之间通信的规则集。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本协议，还需要使用下面一层所提供的服务。本层只能看见本层的服务，看不见下层的协议，即下层的协议对上层服务的实体而言是透明的。</p>
<p>（2）协议是“水平的”，即协议是控制<strong>对等实体之间通信的规则</strong>。但服务是“垂直的”，即服务是<strong>由下层向上层通过层间接口</strong>提供的。</p>
<h3 id="1-2-计算机网络有哪些层？"><a href="#1-2-计算机网络有哪些层？" class="headerlink" title="1.2 计算机网络有哪些层？"></a>1.2 计算机网络有哪些层？</h3><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20230426154530411.png" alt="image-20230426154530411"></p>
<p>五层协议各层（自上到下）的功能：</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>（对应七层协议中的应用层、表示层、会话层）</p>
<p>通过一台<strong>主机内进程间的交互</strong>来完成<strong>特定网络应用</strong>，为操作系统或网络应用程序提供访问<strong>网络服务</strong>的接口。</p>
<p>包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。</p>
<p>数据单位：<strong>报文</strong>。</p>
<h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p>负责为两台主机进程之间的通信提供<strong>通用的数据传输服务</strong>，负责将数据可靠地传送到相应的端口。</p>
<p>运输层包括两种协议：</p>
<p>**传输控制协议TCP：Transmission Control Protocol ** 提供面向连接、可靠的数据传输服务，数据单位为报文段；TCP 主要提供完整性服务。</p>
<p>**用户数据报协议UDP：User Datagram Protocol ** 提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。UDP 主要提供及时性服务。</p>
<p>重要设备：<strong>网关</strong>。</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p><em>网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信</em></p>
<p>网络层为<strong>主机间</strong>提供数据传输服务，而运输层协议是为<strong>主机中</strong>的进程提供服务。</p>
<p>网络层会选择合适的<strong>网间路由和交换结点， 确保数据及时传送</strong></p>
<p>网络层把<strong>运输层</strong>传递下来的报文段或者用户数据报封装成<strong>分组或包</strong>。</p>
<p>在TCP/IP体系中，网络层使用IP协议，因此分组也叫做IP数据报。</p>
<p>基本数据单位：<strong>IP数据报</strong>；</p>
<p>包含协议：</p>
<ul>
<li>IP协议（Internet Protocol，因特网互联协议）;</li>
<li>ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;</li>
<li>ARP协议（Address Resolution Protocol，地址解析协议）;</li>
<li>RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）</li>
</ul>
<p>重要设备：<strong>路由</strong></p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>链路层协议就是为同一链路的结点之间提供服务。数据链路层把网络层传来的分组封装成帧，在两个相邻结点间的链路上传送帧。为网络层提供可靠的数据传输；</p>
<p>基本数据单位：<strong>帧</strong>；</p>
<p>主要的协议：以太网协议；</p>
<p>两个重要设备：<strong>网桥、交换机</strong></p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>考虑的是怎样在物理媒体上传输数据比特流，而不是指具体的物理媒体（传输媒体指双绞线、同轴电缆等）。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p>
<h3 id="1-3-面向连接的服务以及无连接的服务"><a href="#1-3-面向连接的服务以及无连接的服务" class="headerlink" title="1.3 面向连接的服务以及无连接的服务"></a>1.3 面向连接的服务以及无连接的服务</h3><p>（1）面向连接的服务：是指通信前需要建立连接，通信结束后需要进行连接释放。整个过程包括，连接建立、数据传送、连接释放。是按序传送、可靠传送的。 </p>
<p>（2）无连接的服务：传送数据之前不许要建立连接，随时传就行，速度快，简单，但是无法避免数据的丢失、重复等只能“尽最大努力地交付”，是不可靠地传输。</p>
<h3 id="1-4-对等层、协议栈、实体、协议概念"><a href="#1-4-对等层、协议栈、实体、协议概念" class="headerlink" title="1.4 对等层、协议栈、实体、协议概念"></a>1.4 对等层、协议栈、实体、协议概念</h3><p>对等层 两个相同层次的层之间，好像把数据通过水平虚线直接传递给对方，就叫做对等层。</p>
<p>协议栈 因为几个层次画在一起很像一个栈的结构。</p>
<p>实体 实体是任何可发送或接收信息的硬件或软件进程。</p>
<p>协议 协议是控制两个对等实体进行通信的规则的集合。</p>
<p>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本协议，还需要使用下面一层所提供的服务。</p>
<p>协议是“水平的”，即协议是控制对等实体之间通信的规则。但服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。</p>
<h2 id="第二章物理层"><a href="#第二章物理层" class="headerlink" title="第二章物理层"></a>第二章物理层</h2><h3 id="2-1-物理层作用"><a href="#2-1-物理层作用" class="headerlink" title="2.1 物理层作用"></a>2.1 物理层作用</h3><p>主要是规定了通信结点和通信链路之间的连接的接口的一些特性。包括机械特性、电气特性、功能特性和过程特性。规定了通信链路上传输的信号的意义以及电气特性。功能是在物理媒体上为数据端的设备透明的传输原始的比特流。</p>
<h3 id="2-2-物理层主要设备"><a href="#2-2-物理层主要设备" class="headerlink" title="2.2 物理层主要设备"></a>2.2 物理层主要设备</h3><p>（1）中继器：起到的是信号再生的作用（数字信号），与放大器不同（模拟信号）。 </p>
<p>（2）集线器：多端口的中继器。 </p>
<p>（3）注意：物理层的设备均不支持存储转发功能，所以连接的两端必须使用同一个协议，且连接的两端是同一个局域网的不同的网段。 另外，物理层的设备不阻隔冲突域，也不阻隔广播域，它就是个最便宜的设备。</p>
<h3 id="2-3-数据交换的方式"><a href="#2-3-数据交换的方式" class="headerlink" title="2.3 数据交换的方式"></a>2.3 数据交换的方式</h3><p>（1）电路交换：建立连接（独占），数据传输，连接释放。 </p>
<p>（2）报文交换：结点具有存储转发功能，但是转发延迟的问题太大以及结点不好管理存储空间。 </p>
<p>（3）分组交换：采用存储转发方式，限制了每次传送的数据块大小上限，把大的数据块划分成合理地小数据块，再加上控制信息构成分组。</p>
<p>分组交换又分为：数据报交换与虚电路交换（虚电路之所以是“虚”的，是因为这条电路不是专用的，每个节点到其他节点之间的链路可能有若干虚电路通过，也可能同时与多个节点之间建立虚电路）</p>
<h2 id="第三章数据链路层"><a href="#第三章数据链路层" class="headerlink" title="第三章数据链路层"></a>第三章数据链路层</h2><h3 id="3-1-数据链路层的功能"><a href="#3-1-数据链路层的功能" class="headerlink" title="3.1 数据链路层的功能"></a>3.1 数据链路层的功能</h3><p>在物理层提供服务的基础上为网络层提供服务。主要是加强物理层传输原始比特流的能力，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路。</p>
<h3 id="3-2-数据交换的三种方式的对比"><a href="#3-2-数据交换的三种方式的对比" class="headerlink" title="3.2 数据交换的三种方式的对比"></a>3.2 数据交换的三种方式的对比</h3><p>（1）电路交换：三步骤，建立连接–&gt;传输数据–&gt;连接释放。建立连接的时间比较长。且独占信道，适合传输数据量大的时候，信道利用率低且一旦出差错就会导致数据传输失败，无法控制。</p>
<p>（2）报文交换：不需要建立连接，随时发随时接收即可。结点具有存储转发的功能，每个结点接受整个报文之后进行检测，检测无误执行转发，故会存在延迟时间。缺点就是报文大小不确定，结点的存储管理不好控制，且延迟时间较长。</p>
<p>（3）分组交换：将报文划分为长度相同的分组，每个分组都有相应的原地址+目的地址+序号等信息，进行存储转发操作。好处是，分组可以可以并行进行转发，延迟时间缩短且因为分组大小固定所以易于存储的管理。缺点就是，因为每个分组都要加地址信息以及编号之类的，所以增加了传输的数据量。</p>
<h3 id="3-3-数据链路层主要完成的功能"><a href="#3-3-数据链路层主要完成的功能" class="headerlink" title="3.3 数据链路层主要完成的功能"></a>3.3 数据链路层主要完成的功能</h3><p>包括为网络层提供服务、链路管理、帧定界、帧同步、透明传输、差错控制、流量控制、随机访问介质访问控制（协议）</p>
<h3 id="3-4-组帧的定义"><a href="#3-4-组帧的定义" class="headerlink" title="3.4 组帧的定义"></a>3.4 组帧的定义</h3><p>组帧：包括帧定界、帧同步、透明传输</p>
<p>数据链路层将从网络层获得的IP数据包封装成帧，然后进行传输，封装成帧的时候要添加帧首部和帧尾部，用于提取出数据部分。</p>
<h3 id="3-5-组帧的方式"><a href="#3-5-组帧的方式" class="headerlink" title="3.5 组帧的方式"></a>3.5 组帧的方式</h3><p>（1）字符计数法：在帧首部添加计数字段，记录该帧数据的长度。</p>
<p>（2）字符填充的首位定界法：用特殊的字符去作为首位定界符。对于数据中可能出现的特殊字符，则在其前面加上一个转义字符，接收的时候自动去掉即可。</p>
<p>（3）零比特填充的首位定界标志：01111110作为开始和结束的表示，为了防止数据中出现这样的串而出现提前终止的情况，我们对数据中连续的11111后面加一个0，接收的时候相反处理即可，硬件处理。</p>
<p>（4）违规编码法：适用于冗余编码的时候，比如我们的差分曼彻斯特编码（由高到低表示0，则由低到高表示1，高高和低低就是违规编码），我们用违规编码作为定界符即可，但是只适用于冗余编码。</p>
<h3 id="3-6-差错控制"><a href="#3-6-差错控制" class="headerlink" title="3.6 差错控制"></a>3.6 差错控制</h3><p>检错编码（奇偶校验、CRC）和纠错编码（海明码）</p>
<h3 id="3-7-流量控制"><a href="#3-7-流量控制" class="headerlink" title="3.7 流量控制"></a>3.7 流量控制</h3><p>就是限制发送方的发送速度，使得接收方可以正确的接收数据。 （1）停止等待协议：发送窗口大小=1，接受窗口大小=1 （2）后退N帧：发送窗口大小&gt;1，接受窗口大小=1 （3）选择重发：发送窗口大小&gt;1，接受窗口大小&gt;1 （2）和（3）有一个共同点就是t+w&lt;=2^n,n为编号的二进制数，否则容易产生若确认帧丢失接收方无法分清新帧旧帧的情况。 （4）这些包括了自动重传机制，即确认，超时重传机制可以确保可靠传输。</p>
<h3 id="3-8-随机访问介质访控制机制"><a href="#3-8-随机访问介质访控制机制" class="headerlink" title="3.8 随机访问介质访控制机制"></a>3.8 随机访问介质访控制机制</h3><p>在局域网中是总线型的，广播式的发送，所以必须为了防止冲突采取一些措施。</p>
<p>（1）随机接入系统ALOHA：纯ALOHA、时域ALOHA协议</p>
<p>（2）CSMA（载波监听多路访问）：1坚持、非坚持、P坚持。</p>
<p>（3）CSMA/CD(碰撞检测)：先听后发、边听边发、冲突停发、随机重发。适合有线网（局域网）。 1）存在争用期，因为必须保证检测到冲突的时候数据还没发完，所以2*端到端的传播时间必须小于数据的发送延时。即可以确定最小帧长（以太网的最小帧长是64B） 2）随机重发的策略是二进制指数退避算法来防止再次冲突。</p>
<p>（4）CSMA/CA（碰撞避免）：包括预约信道、ACK、RTS、CTS，适用于无线网。并不能完全避免，只能尽量的避免，在发送的过程中不检测冲突。 1）数据发送前先预约信道，告诉其他设备我要发数据，在此期间你们别发。 2）随机重发的策略是二进制指数退避算法来防止再次冲突。</p>
<h3 id="3-9-局域网"><a href="#3-9-局域网" class="headerlink" title="3.9 局域网"></a>3.9 局域网</h3><p>局域网是指在一个较小的地理范围内，将各种计算机、外部设备和数据库系统等通过双绞线、同轴电缆等连接介质互相连接起来，组成资源和信息共享的计算机互联网络。</p>
<h3 id="3-10-数据链路层在广域网中的协议"><a href="#3-10-数据链路层在广域网中的协议" class="headerlink" title="3.10 数据链路层在广域网中的协议"></a>3.10 数据链路层在广域网中的协议</h3><p>（1）PPP协议：按字节传输的，点到点的协议，不可靠，只检错丢弃，不纠错，不适用序号和确认机制。支持全双工。</p>
<p>（2）HDLC（高级数据链路控制协议）：面向比特，提供可靠传输（使用了编号和确认机制），用的是0比特插入法实现透明传输。</p>
<h3 id="3-11-链路层设备（局域网中）"><a href="#3-11-链路层设备（局域网中）" class="headerlink" title="3.11 链路层设备（局域网中）"></a>3.11 链路层设备（局域网中）</h3><p>隔离冲突域，不隔离广播域</p>
<p>（1）网桥：一次只能转发一个帧。</p>
<p>（2）交换机：多端口的网桥，解决网桥一次只能转发一帧的不足。有直通式、存储转发式。</p>
<h2 id="第四章网络层"><a href="#第四章网络层" class="headerlink" title="第四章网络层"></a>第四章网络层</h2><h3 id="4-1-IP地址与MAC地址的区别"><a href="#4-1-IP地址与MAC地址的区别" class="headerlink" title="4.1 IP地址与MAC地址的区别"></a>4.1 IP地址与MAC地址的区别</h3><p>（1）举个栗子，就像是你接收快递时所填的家庭地址和你的个人信息一样。IP地址就是你的住址，这个是可以变的，但是你的个人信息，也就是你的身份证号码是不会变的。 （2）链路层传输需要的是物理地址MAC，网络之间通过路由器转发分组需要的地址是IP地址。 （3）IP地址是逻辑的，MAC地址基于物理设备。</p>
<h3 id="4-2-IPV4和IPV6的区别"><a href="#4-2-IPV4和IPV6的区别" class="headerlink" title="4.2 IPV4和IPV6的区别"></a>4.2 IPV4和IPV6的区别</h3><p>（1）IPV4地址32位，IPV6地址128位。IPV6的出现是为了解决IPV4地址不够用等问题。</p>
<p>（2）IPV6提高安全性。身份认证和隐私权是IPV6的关键特性。</p>
<h3 id="4-3-如何实现IPV4和IPV6的互联"><a href="#4-3-如何实现IPV4和IPV6的互联" class="headerlink" title="4.3 如何实现IPV4和IPV6的互联"></a>4.3 如何实现IPV4和IPV6的互联</h3><p>（1）双栈技术（IPV4协议栈和IPV6协议栈）：数据链路层根据收到的IP数据报进行解析其头部第一个字段，即版本，版本位4就用IPV4协议栈去处理，版本位6就用IPV6协议栈去处理。</p>
<p>（2）隧道技术：实现IPV6的较完整运行。隧道技术是在IPv6网络与IPv4网络间的隧道入口处，由路由器将IPv6的数据分组封装到IPv4分组中。IPv4分组的源地址和目的地址分别是隧道入口和出口的IPv4地址。在隧道的出口处拆封IPv4分组并剥离出IPv6数据包。</p>
<h3 id="4-4-虚电路与数据报比较"><a href="#4-4-虚电路与数据报比较" class="headerlink" title="4.4 虚电路与数据报比较"></a>4.4 虚电路与数据报比较</h3><p>（1）虚电路需要建立连接，是有序的，能够保证数据传输的质量，但是灵活性不够强，结点出现问题所有经过此节点的虚电路都不能用了。</p>
<p>（2）数据报交换：无连接不可靠，但是灵活。</p>
<h3 id="4-5-子网的划分和掩码"><a href="#4-5-子网的划分和掩码" class="headerlink" title="4.5 子网的划分和掩码"></a>4.5 子网的划分和掩码</h3><p>（1）主要是为了提高IP利用率，就是公有IP的利用率。</p>
<p>（2）还可以减小广播域（注意不是减少，是减小！！！）</p>
<p>（3）便于IP的管理。</p>
<h3 id="4-6-因特网中的两大类路由选择协议"><a href="#4-6-因特网中的两大类路由选择协议" class="headerlink" title="4.6 因特网中的两大类路由选择协议"></a>4.6 因特网中的两大类路由选择协议</h3><p>（1）域内路由选择协议IGP：RIP（UDP，用的路由选择算法是距离向量，最多15跳）、OSPF（IP，用的路由选择算法是链路状态，其中用到了迪杰斯特拉最短路径求解算法）。</p>
<p>（2）域间路由选择协议EGP：BGP（TCP）</p>
<h3 id="4-7-有人认为：“ARP协议向网络层提供转换地址的服务，因此ARP应当属于数据链路层。”正确么？"><a href="#4-7-有人认为：“ARP协议向网络层提供转换地址的服务，因此ARP应当属于数据链路层。”正确么？" class="headerlink" title="4.7 有人认为：“ARP协议向网络层提供转换地址的服务，因此ARP应当属于数据链路层。”正确么？"></a>4.7 有人认为：“ARP协议向网络层提供转换地址的服务，因此ARP应当属于数据链路层。”正确么？</h3><p>不正确。 因为ARP本身是网络层的一部分，ARP协议为IP协议提供了转换地址的服务；数据链路层使用硬件地址而不使用IP地址，无需ARP协议数据链路层本身即可正常运行。因此ARP不再数据链路层。</p>
<h3 id="4-8-ARP协议"><a href="#4-8-ARP协议" class="headerlink" title="4.8 ARP协议"></a>4.8 ARP协议</h3><p>ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。</p>
<h3 id="4-9-在经过路由器转发的过程中IP数据报中的IP源地址、目的地址以及MAC源地址和目的地址会发生变化吗？"><a href="#4-9-在经过路由器转发的过程中IP数据报中的IP源地址、目的地址以及MAC源地址和目的地址会发生变化吗？" class="headerlink" title="4.9 在经过路由器转发的过程中IP数据报中的IP源地址、目的地址以及MAC源地址和目的地址会发生变化吗？"></a>4.9 在经过路由器转发的过程中IP数据报中的IP源地址、目的地址以及MAC源地址和目的地址会发生变化吗？</h3><p>如果路由器不提供NAT，则IP地址是不会变化的。但是如果提供NAT的话，是会改变的。但是MAC源、目的地址是会变化的。 （1）如果源IP地址是私有IP地址，需要经过路由器的NAT的转换，源地址转换成公有的IP地址，但是目的地址是不变的。 （2）MAC源、目的地址会一直变化，根据所处的位置以及下一条进行变化。</p>
<h2 id="第五章传输层（提供端到端的服务）"><a href="#第五章传输层（提供端到端的服务）" class="headerlink" title="第五章传输层（提供端到端的服务）"></a>第五章传输层（提供端到端的服务）</h2><h3 id="5-1-传输层的两个协议"><a href="#5-1-传输层的两个协议" class="headerlink" title="5.1 传输层的两个协议"></a>5.1 传输层的两个协议</h3><p>无连接不可靠但是很快速的UDP（面向报文）</p>
<p>有连接可靠但是管理麻烦的TCP（面向字节流）</p>
<h3 id="5-2-TCP和UDP首部格式"><a href="#5-2-TCP和UDP首部格式" class="headerlink" title="5.2 TCP和UDP首部格式"></a>5.2 TCP和UDP首部格式</h3><p>UDP：首部只有8B，4个字段（每个占2B），分别为源端口号、目的端口号、长度（是UDP整个的长度）、校验位（校验UDP中的首部+数据）</p>
<p>TCP：20B的首部，包含很多东西。</p>
<h3 id="5-3-如果IP可以可靠传输是不是就不需要UDP了，直接跟应用层联系？"><a href="#5-3-如果IP可以可靠传输是不是就不需要UDP了，直接跟应用层联系？" class="headerlink" title="5.3 如果IP可以可靠传输是不是就不需要UDP了，直接跟应用层联系？"></a>5.3 如果IP可以可靠传输是不是就不需要UDP了，直接跟应用层联系？</h3><p>不可以。IP只能确定主机，但是真正通信的是两台主机中的进程，所以我们需要确定具体的进程也就是需要源端口号和目的端口号，这需要UDP提供。</p>
<h3 id="5-4-TCP的特点"><a href="#5-4-TCP的特点" class="headerlink" title="5.4 TCP的特点"></a>5.4 TCP的特点</h3><p>传输控制协议 TCP（Transmission Control Protocol）</p>
<p>有连接的</p>
<p>每一条 TCP连接只能是点对点的（一对一）</p>
<p>提供可靠交付</p>
<p>全双工通信</p>
<p>有流量控制，拥塞控制，面向字节流</p>
<h3 id="5-5-UDP特点"><a href="#5-5-UDP特点" class="headerlink" title="5.5 UDP特点"></a>5.5 UDP特点</h3><p>用户数据报协议 UDP（User Datagram Protocol）</p>
<p>无连接的</p>
<p>尽最大可能交付</p>
<p>面向报文，对于应用程序传下来的报文不合并也不拆分</p>
<p>没有拥塞控制</p>
<p>支持一对一、一对多、多对一和多对多的交互通信</p>
<p>只是添加 UDP 首部，且首部开销小</p>
<h3 id="5-6-TCP和UDP的区别"><a href="#5-6-TCP和UDP的区别" class="headerlink" title="5.6 TCP和UDP的区别"></a>5.6 TCP和UDP的区别</h3><ol>
<li>TCP提供面向连接的传输；UDP提供无连接的传输</li>
<li>TCP提供可靠的传输（有序，无差错，不丢失，不重复）； UDP提供不可靠的传输。</li>
<li>TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组；UDP是面向数据报的传输，没有分组开销。</li>
<li>TCP提供拥塞控制和流量控制机制；UDP不提供拥塞控制和 流量控制机制。</li>
<li>TCP只能是点对点的（一对一），UDP支持一对一、一对 多、多对一和多对多的交互通信。</li>
<li>TCP传输效率较低，UDP传输效率较高。</li>
</ol>
<h3 id="5-7-TCP建立连接（三次握手）"><a href="#5-7-TCP建立连接（三次握手）" class="headerlink" title="5.7 TCP建立连接（三次握手）"></a>5.7 TCP建立连接（三次握手）</h3><p><img src="https://img-blog.csdnimg.cn/20190414101321191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hvbmd3ZWlfMTk5MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>连接建立前，服务器进程处于LISTEN（收听）状态，等待客户的连接请求。</p>
<p>第1步，客户机的TCP首先向服务器的TCP发出连接<strong>请求报文段</strong>，这时首部中的同步位SYN=1，同时选择一个初始序列seq=x。TCP规定，SYN报文段（即SYN=1的报文段）不能携带数据，但要消耗掉一个序列。这时，TCP客户进程进入SYN-SENT（同步已发送）状态。</p>
<p>第2步，服务器的TCP收到连接请求报文段后，如果<strong>同意建立连接，则向客户机发送确认</strong>。在确认报文段中应把SYN位和ACK位都置1，确认号是ack=x+1，同时也为自己选择一个初始序列seq=y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时TCP服务器进程进入SYN-RCVD（同步收到）状态。</p>
<p>第3步，当客户机收到确认报文段后，还要<strong>向服务器给出确认</strong>，并为该TCP连接分配缓存和变量。确认报文段的ACK=1，确认号ack=y+1，而自己的序列seq=x+1。TCP的标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序列仍是seq=x+1。这时，TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态。</p>
<p>当服务器收到客户机的确认后，也进入ESTABLISHED状态。</p>
<h4 id="5-7-1-TCP三次握手建立连接，两次不行吗？"><a href="#5-7-1-TCP三次握手建立连接，两次不行吗？" class="headerlink" title="5.7.1 TCP三次握手建立连接，两次不行吗？"></a>5.7.1 TCP三次握手建立连接，两次不行吗？</h4><p>不可以。 如果存在已失效的连接请求报文重新传到了服务器端，则服务器会响应然后向客户端发送ACK，此时认为已经建立连接，之后服务器便开始等待客户机传送数据。但是客户机并未响应这个ACK，所以服务器会一直等待下去，造成资源的浪费。</p>
<p>如果有最后一次确认，则在服务器收到滞留的请求并回复之后，客户机不会对服务器的回复做出回复，进而不会建立连接。</p>
<h4 id="5-7-2-四次呢？"><a href="#5-7-2-四次呢？" class="headerlink" title="5.7.2 四次呢？"></a>5.7.2 四次呢？</h4><p>四次太多了，三次就可以双方都确认对方已经做好了接收数据以及发送数据的准备。</p>
<h3 id="5-8-TCP连接释放（四次挥手）"><a href="#5-8-TCP连接释放（四次挥手）" class="headerlink" title="5.8 TCP连接释放（四次挥手）"></a>5.8 TCP连接释放（四次挥手）</h3><p><img src="https://img-blog.csdnimg.cn/2019041418290822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hvbmd3ZWlfMTk5MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>数据传输结束后，通信的双方都可释放连接。</p>
<p>第1步，<strong>客户机打算关闭时，先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。</strong>该报文段的终止位FIN置1，其序列seq=u，它等于前面已传送过的数据的最后一个字节的序列加1。这时客户机进入FIN-WAIT-1（终止等待1）状态。请注意，TCP规定，FIN报文段即使不携带数据，它也要消耗一个序列。</p>
<p>第2步，<strong>服务器收到连接释放报文，发出确认报文</strong>，ACK=1，ack=u+1，并且<strong>带上自己的序列号seq=v</strong>，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。此时，从客户机到服务器这个方向的连接就释放了，TCP处于半关闭状态。但服务器若发送数据，客户机仍要接收，即从服务器到客户机这个方向的连接并未关闭。</p>
<p>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）</p>
<p>第3步，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，重复上次已发送的确认号ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p>
<p>第4步，客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，客户机才进入CLOSED（连接关闭）状态。</p>
<p>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。</p>
<h4 id="5-8-1-TCP四次挥手（握手）释放连接，为啥需要四次而不是三次？"><a href="#5-8-1-TCP四次挥手（握手）释放连接，为啥需要四次而不是三次？" class="headerlink" title="5.8.1 TCP四次挥手（握手）释放连接，为啥需要四次而不是三次？"></a>5.8.1 TCP四次挥手（握手）释放连接，为啥需要四次而不是三次？</h4><p>（1）是因为可能有部分数据需要处理。 </p>
<p>（2）建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。 </p>
<p>（3）释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。但是连接释放请求的时候，第二次发送的只是ACK，并没有FIN，是因为服务器可能还需要传送一些数据，所以要等待传送完毕之后才能再次给客户端发送FIN=1的连接释放报文。</p>
<h4 id="5-8-2-TCP四次挥手为啥第四次客户机发送ACK之后要等待2MSL之后才能真的关闭？"><a href="#5-8-2-TCP四次挥手为啥第四次客户机发送ACK之后要等待2MSL之后才能真的关闭？" class="headerlink" title="5.8.2 TCP四次挥手为啥第四次客户机发送ACK之后要等待2MSL之后才能真的关闭？"></a>5.8.2 TCP四次挥手为啥第四次客户机发送ACK之后要等待2MSL之后才能真的关闭？</h4><p>1）MSL是最大报文段生存周期。客户机发送ACK后如果MSL后服务器端没有接受到，就会再次发送一个请求释放报文，这一过程总的到达客户端的时间最多就是2MSL，所以一旦ACK出现丢失，那么2MSL内客户机一定可以得到消息，然后重新发送ACK，再次重新计时。 </p>
<p>2）如果客户机发送ACK之后就关闭了，那么如果出现ACK丢失的现象，即使服务器端再次重新发送请求释放报文，它也不会理会，就会导致服务器端无法结束。 3）还可以防止已失效的连接请求报文。</p>
<h3 id="5-9-重传的两种方法"><a href="#5-9-重传的两种方法" class="headerlink" title="5.9 重传的两种方法"></a>5.9 重传的两种方法</h3><p>1）超时重传：根据RTT均值设置一个超时重传的时间。但是这种方法不好的点在于慢。但是这种情况预示着此时拥塞很严重了。</p>
<p>2）冗余ACK：利用TCP接受数据的特点，当前未接受的数据k而言，如果k后的数据到达，每次都会产生一个ACK的确认序号为k，3个这样的就表示需要为k的报文段丢失需要重发。这样的好处是快，而且此时没有那么的拥塞。</p>
<h3 id="5-10-TCP实现可靠传输的方式"><a href="#5-10-TCP实现可靠传输的方式" class="headerlink" title="5.10 TCP实现可靠传输的方式"></a>5.10 TCP实现可靠传输的方式</h3><h4 id="5-10-1-停止等待协议"><a href="#5-10-1-停止等待协议" class="headerlink" title="5.10.1 停止等待协议"></a>5.10.1 停止等待协议</h4><p>每发送一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p>
<h4 id="5-10-2-流量控制"><a href="#5-10-2-流量控制" class="headerlink" title="5.10.2 流量控制"></a>5.10.2 流量控制</h4><p>让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<h4 id="5-10-3-拥塞控制"><a href="#5-10-3-拥塞控制" class="headerlink" title="5.10.3 拥塞控制"></a>5.10.3 拥塞控制</h4><p>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p>
<p>四种算法：</p>
<p>1、慢开始：由小到大逐渐增大拥塞窗口，每经过一个传输轮次，拥塞窗口加倍</p>
<p>2、拥塞避免：每经过一个传输轮次，拥塞窗口加1 </p>
<p>3、快重传：立即发送确认，让发送方尽早知道发生了个别报文段的丢失 </p>
<p>4、快恢复：只是丢失个别的报文段时可以执行快恢复，调整限制到原拥塞窗口的1/2</p>
<h2 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h2><h3 id="6-1-应用层传输的方式"><a href="#6-1-应用层传输的方式" class="headerlink" title="6.1 应用层传输的方式"></a>6.1 应用层传输的方式</h3><p>C/S方式、P2P点对点方式（平等的，每个主机既可以作为Client也可以作为Service）</p>
<h3 id="6-2-域名解析协议DNS"><a href="#6-2-域名解析协议DNS" class="headerlink" title="6.2 域名解析协议DNS"></a>6.2 域名解析协议DNS</h3><p>域名系统(Domain Name System缩写 DNS)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（基于UDP)</p>
<h3 id="6-3-FTP（文件传输协议）"><a href="#6-3-FTP（文件传输协议）" class="headerlink" title="6.3 FTP（文件传输协议）"></a>6.3 FTP（文件传输协议）</h3><p>控制连接（端口号21），数据连接（一般是端口号20），是两个并行的TCP连接，数据传输结束立即断开数据连接。</p>
<h3 id="6-4-SMTP以及POP3：（基于TCP）"><a href="#6-4-SMTP以及POP3：（基于TCP）" class="headerlink" title="6.4 SMTP以及POP3：（基于TCP）"></a>6.4 SMTP以及POP3：（基于TCP）</h3><p>（1）SMTP：简单邮件传输协议，只传输二进制信息，在用户代理—&gt;邮件服务器，以及邮件服务器–&gt;邮件服务器之间的邮件的传输。（Push的方式）</p>
<p>（2）POP3：邮局协议，是传输从邮件服务器到用户代理。（Pull的方式）</p>
<h3 id="6-5-HTTP-基于TCP有连接"><a href="#6-5-HTTP-基于TCP有连接" class="headerlink" title="6.5 HTTP(基于TCP有连接)"></a>6.5 HTTP(基于TCP有连接)</h3><p>超文本传输协议HTTP（HyperText Transfer Protocol），HTTP是面向事务的应用层协议。定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。HTTP是万维网上能够可靠地交换文件的重要基础。</p>
<h3 id="6-6-HTTP中GET和POST的区别"><a href="#6-6-HTTP中GET和POST的区别" class="headerlink" title="6.6 HTTP中GET和POST的区别"></a>6.6 HTTP中GET和POST的区别</h3><p>1、从原理性看：</p>
<p>GET用于信息获取，而且应该是安全的；POST请求表示可能修改服务器上资源的请求。</p>
<p>2、从表面上看：</p>
<p>GET请求的数据会附在URL后面，POST的数据放在HTTP包体，POST安全性比GET安全性高。</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="浏览器请求一个网址的过程？"><a href="#浏览器请求一个网址的过程？" class="headerlink" title="浏览器请求一个网址的过程？"></a>浏览器请求一个网址的过程？</h2><p>  （1）首先是解析域名，DNS进行，获得IP地址。然后端口号发送端随机分配，服务器是固定的80端口。</p>
<p>  （2）知道IP和端口号之后就可以建立3次握手建立TCP连接。</p>
<p>  （3）发送HTTP请求报文。</p>
<p>  （4）服务器处理浏览器发来的请求，返回要显示的页面html信息。</p>
<p>  （5）传输结束，4次握手释放连接。 </p>
<p>  （6）显示页面。</p>
<h2 id="概述五层？"><a href="#概述五层？" class="headerlink" title="概述五层？"></a>概述五层？</h2><p>五层协议各层（自上到下）的功能：</p>
<h4 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h4><p>（对应七层协议中的应用层、表示层、会话层）</p>
<p>通过一台<strong>主机内进程间的交互</strong>来完成<strong>特定网络应用</strong>，为操作系统或网络应用程序提供访问<strong>网络服务</strong>的接口。</p>
<p>包含的主要协议：FTP（文件传送协议、TCP、21）、Telnet（远程登录协议、TCP、23）、DNS（域名解析协议、区域传输的时候使用TCP协议，其他时候使用UDP协议、53）、SMTP（邮件传送协议、TCP、25），POP3 协议（邮局协议，用于接收邮件、TCP、110），HTTP协议（Hyper Text Transfer Protocol、UDP、80）。</p>
<p>数据单位：<strong>报文</strong>。</p>
<h4 id="运输层-1"><a href="#运输层-1" class="headerlink" title="运输层"></a>运输层</h4><p>负责为两台主机进程之间的通信提供<strong>通用的数据传输服务</strong>，负责将数据可靠地传送到相应的端口。</p>
<p>运输层包括两种协议：</p>
<p>**传输控制协议 TCP：Transmission Control Protocol ** 提供面向连接、可靠的数据传输服务，数据单位为报文段；TCP 主要提供完整性服务。</p>
<p>**用户数据报协议 UDP：User Datagram Protocol ** 提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报；UDP 主要提供及时性服务。</p>
<p>重要设备：<strong>网关</strong>。</p>
<h4 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h4><p><em>网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信</em></p>
<p>网络层为<strong>主机间</strong>提供数据传输服务，而运输层协议是为<strong>主机中</strong>的进程提供服务。</p>
<p>网络层会选择合适的<strong>网间路由和交换结点， 确保数据及时传送</strong></p>
<p>网络层把<strong>运输层</strong>传递下来的报文段或者用户数据报封装成<strong>分组或包</strong>。</p>
<p>在TCP/IP体系中，网络层使用IP协议，因此分组也叫做IP数据报。</p>
<p>基本数据单位：<strong>IP数据报</strong>；</p>
<p>包含协议：</p>
<ul>
<li>IP协议（Internet Protocol，因特网互联协议）;</li>
<li>ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;</li>
<li>ARP协议（Address Resolution Protocol，地址解析协议）;</li>
<li>RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）</li>
</ul>
<p>重要设备：<strong>路由</strong></p>
<h4 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>链路层协议就是为同一链路的结点之间提供服务。数据链路层把网络层传来的分组封装成帧，在两个相邻结点间的链路上传送帧。为网络层提供可靠的数据传输；</p>
<p>重要功能：<strong>流量控制</strong></p>
<p>基本数据单位：<strong>帧</strong>；</p>
<p>主要的协议：以太网协议；</p>
<p>两个重要设备：<strong>网桥、交换机</strong></p>
<h4 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h4><p>考虑的是怎样在物理媒体上传输数据比特流，而不是指具体的物理媒体（传输媒体指双绞线、同轴电缆等）。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p>
<h2 id="概述ARP协议？"><a href="#概述ARP协议？" class="headerlink" title="概述ARP协议？"></a>概述ARP协议？</h2><p>计算机中会维护一个 ARP缓存表，这个表记录着IP地址与MAC地址的映射关系。</p>
<p>我们可以通过在电脑的控制台通过arp -a指令查看一下我们自己计算机的ARP缓存表。</p>
<p><strong>地址解析协议（Address Resolution Protocol，ARP）是通过解析<code>IP地址</code>得到<code>MAC地址</code>的</strong>，是一个在网络协议包中极其重要的网络传输协议，它与网卡有着极其密切的关系。</p>
<h2 id="概述DHCP协议？"><a href="#概述DHCP协议？" class="headerlink" title="概述DHCP协议？"></a>概述DHCP协议？</h2><p><strong>DHCP</strong>协议，Dynamic Host Configuration Protocol，又称为<strong>动态主机配置协议</strong>，<strong>DHCP允许主机自动获取IP地址</strong>。DHCP是一种客户端-服务器协议，在应用层实现，采用UDP <strong>主机获取IP地址步骤</strong>：</p>
<ol>
<li>主机广播DHCP发现报文</li>
<li>DHCP服务器回应ACK，并携带分配给它的IP地址，表示提供服务</li>
<li>主机广播DHCP请求，表示我打算连接到你分配的IP地址，同时也相当于告诉其他DHCP服务器，我已经打算连接到这个DHCP服务器的IP地址了，你们分配的IP地址可收回了</li>
<li>DHCP服务器最后回复ACK报文。</li>
</ol>
<h2 id="概述NAT协议？"><a href="#概述NAT协议？" class="headerlink" title="概述NAT协议？"></a>概述NAT协议？</h2><p><strong>NAT</strong>又称为<strong>网络地址转换</strong>，<strong>为本地私有网络提供合法IP地址</strong>，连接到外部网络 NAT不仅能解决IP地址不足的问题，而且能有效避免被攻击，隐藏和保护内部计算机。</p>
<p>NAT的转换方式主要有三种： </p>
<p><strong>静态转换</strong>：将私有网络的某IP地址转换成特定的合法IP地址，一对一静态转换</p>
<p><strong>动态转换</strong>：将私有网络的IP地址转换成合法IP地址时，是不确定的，可以随机转换成任意指定的合法IP地址 </p>
<p><strong>端口多路复用</strong>：将私有网络的IP地址转换成合法IP地址时，所有私有网络主机共享一个合法IP地址，每个主机转换为端口号，进行外部网络的访问。</p>
<h2 id="概述ICMP协议？"><a href="#概述ICMP协议？" class="headerlink" title="概述ICMP协议？"></a>概述ICMP协议？</h2><p>ICMP协议，Internet Control Message Protocol，又称为<strong>互联网控制报文协议</strong>，属于IP协议的一部分。</p>
<p>ICMP协议的主要服务是为网络层提供差错信息及其他信息，ICMP报文是被封装到IP数据报中进行传输的。</p>
<p>两类ICMP报文：</p>
<p>差错控制报文：目的不可达，源抑制，超时超期，参数问题，重定向等</p>
<p>网络探寻报文：回声请求与应答报文，时间戳请求与应答报文</p>
<p><strong>运用ICMP的应用</strong> tracerooute：运用超时超期（TTL超时）和目的端口不可达的ICMP差错报文 ping：利用回显请求与应答报文。</p>
<h2 id="概述路由算法？"><a href="#概述路由算法？" class="headerlink" title="概述路由算法？"></a>概述路由算法？</h2><ul>
<li><strong>链路状态路由算法（LS）</strong> 全局式的路由选择算法 每个节点有本网络所有的网络拓扑以及链路费用的全局信息 运用迪杰斯特拉（Dijkstra）算法计算最短路由选择 <strong>特点</strong> 向网络上所有其他节点广播消息 消息仅包括到邻居节点的费用 收敛速度较快 存在震荡现象（当费用与通信量相关时）</li>
<li><strong>距离向量路由算法（DV）</strong> 分布式的路由算则算法 每个节点仅保存通往目的地的最短路径的下一跳，通过迭代的方式计算出路径选择 每个节点从直接相连的邻居处获取信息，然后计算，若有变化，则将计算结果分发给直接相连的邻居 每个节点直接检测到链路费用，更新路由信息，若变化，发送给所有直接的邻居 <strong>特点</strong> 分布式，迭代，异步的路由算法 仅向直接相连的邻居交换信息 每个节点仅保存通往目的地最短路径的下一跳 收敛速度慢 好消息传播快，坏消息传播慢 存在无穷计数的问题，解决办法为毒性逆转，（如果A通往目的地的最短路径的下一跳是B，则当B询问B通过A去目的地的最短路径时，A回复无穷大）</li>
<li><strong>层次路由选择</strong> 将一个大规模网络分为多个自治系统（AS），每个自治系统内运行相同的路由算法，称为自治系统内部路由选择协议（如RIP，OSPF） 两个自治系统AS之间的通信运行自治系统间路由选择协议（如BGP）</li>
<li><strong>RIP</strong> 路由选择信息协议（Routing Information Protocol） 基于距离向量路由算法（DV），定义跳数为其链路费用 RIP被当做一个应用进程来实现，交换信息使用UDP RIP通常被用于小规模网络，下层ISP及公司网络</li>
<li><strong>OSPF</strong> 开放最短路优先协议（Open Shortest Path First） 基于链路状态路由算法（LS） 当一条链路费用变化时，节点向网络中所有节点广播路由选择信息 每个节点使用Dijkstra算法计算最低费用路径选择 OSPF更复杂，也有很多<strong>优点</strong>： 安全 可以有多条相同费用路径，当需要传递大量分组时，有多个选择，充分利用 支持单播和多播路由 OSPF支持在AS内部进一步分层</li>
<li><strong>BGP</strong> 边界网关协议（Border Gateway Protocol）,自治系统间的路由选择协议 eBGP，从邻居子网获取可达信息 iBGP，向本子网内节点传递子网可达信息 基于可达信息的路径，确定到达外部子网的好的路径</li>
</ul>
<hr>
<h2 id="概述数据链路层的服务？"><a href="#概述数据链路层的服务？" class="headerlink" title="概述数据链路层的服务？"></a>概述数据链路层的服务？</h2><p>基本服务：将网络层的数据报封装成数据帧，通过单一通信链路从一个节点传输到另一个节点 链路层的主体是在<strong>网络适配器</strong>上实现的 链路层信道主要分为两类，点对点链路（PPP），和广播链路。</p>
<h2 id="概述MAC协议？"><a href="#概述MAC协议？" class="headerlink" title="概述MAC协议？"></a>概述MAC协议？</h2><p>MAC协议称为多路访问控制协议 主要能分为三类：<strong>信道划分协议</strong>，<strong>随机接入协议</strong>，<strong>轮流协议</strong></p>
<ul>
<li><strong>信道划分协议</strong> 主要分为时分多路复用（TDM），频分多路复用（FDM），码分多址（CDMA） 相当于是为每一个可能使用的人预留了一段资源，每个人在自己分配的那段资源里传输数据，所以一定不会发生碰撞 当某时刻用的人很多时，利用率高 当某时刻用的人很少时，利用率低</li>
<li><strong>随机接入协议</strong> 基本思想是：当用户有数据需要发送时，就直接发送，如果与其他人发生碰撞了，就等一个随机时延，再重新发送，直到没有碰撞发生，发送成功为止 主要有<strong>时隙ALOHA</strong>，<strong>ALOHA</strong>，<strong>CSMA</strong>，<strong>CSMA/CD</strong>协议 <strong>时隙ALOHA</strong>将时间划分若干时隙，规定所有人只能在某一个时隙的起始点发送数据 <strong>ALOHA</strong>则没有这个规定，所有人可以在任何时间发送数据 时隙ALOHA的效率比ALOHA协议的效率要高一倍左右 <strong>CSMA</strong>协议称为载波侦听多路访问，即发送数据之前先侦听信道，当没有人发送数据时，才发送数据 <strong>CSMA/CD</strong>协议称为带碰撞检测的载波侦听多路访问协议，在CSMA基础上加了碰撞检测，若检测到碰撞，则都立即停止发送，等一个随机时间后再次发送 既然所有人都侦听了，为什么还会发生碰撞呢？原因是存在传播延迟。 随机接入协议，当某时刻用的人少时，效率很高 用的人多时，发生碰撞概率高，效率较低</li>
<li><strong>轮流协议</strong> 按照一定的轮流规则，所有需要发送数据的人轮流发送数据，轮到谁就谁发。 主要有 <strong>轮询协议</strong>：主节点轮流通知每个节点，你可以发送数据了，如果你有数据，就发，没数据，就过 缺点：带来额外的轮询消耗；如果主节点发生故障，则后果严重 <strong>令牌传递</strong>：某种称为令牌的特殊帧在节点之间按特定次序传递，令牌传递到的节点才可以发送数据。 缺点：同样带来消耗，某一节点发生故障也可能给整个信道带来奔溃。</li>
</ul>
<h2 id="概述MAC地址与ARP协议？"><a href="#概述MAC地址与ARP协议？" class="headerlink" title="概述MAC地址与ARP协议？"></a>概述MAC地址与ARP协议？</h2><p>每一个网络设备的适配器都有自己的链路层地址，MAC地址，这个地址是子自生产出来就是唯一的。数据链路层需要通过MAC地址来转发数据帧来通过交换机网络</p>
<p><strong>ARP协议</strong>称为地址解析协议，提供了IP地址转换为链路层MAC地址的机制 IP地址相当于邮政地址，MAC地址相当于身份证号</p>
<p><strong>ARP工作原理</strong>： 每台主机或路由器都保存有一张ARP表，表中包含IP地址与MAC地址的映射关系 当表中有目的IP地址的信息时，就直接交给链路层进行发送 如果表中还没有相关信息，则在本子网内发送ARP广播查询，若此IP目的节点收到后应回复一个ARP应答报文 所以ARP是自适应的，自动建立的，即插即用的。</p>
<h2 id="概述以太网？"><a href="#概述以太网？" class="headerlink" title="概述以太网？"></a>概述以太网？</h2><p>以太网是目前有限局域网中具有统治地位的局域网类型 其多路访问控制协议采用CSMA/CD协议 现阶段总线型拓扑结构以太网已被星型拓扑结构所取代 星型拓扑结构中，集线器已被交换机所取代</p>
<h2 id="概述链路层交换机？"><a href="#概述链路层交换机？" class="headerlink" title="概述链路层交换机？"></a>概述链路层交换机？</h2><p>链路层交换机是数据链路层设备，其提供的主要服务为转发与过滤 链路层交换机所提供的服务是基于MAC地址的 交换机的转发与过滤借助于维护一个交换机表，表中有MAC地址与端口的对应关系 <strong>转发</strong>：指的是将具有目的MAC地址的数据帧从某个端口转发出去，若没有该表项，则广播该帧 <strong>过滤</strong>：如果MAC地址所对应的端口与数据帧进来的端口号相同，则丢弃</p>
<p>交换机是<strong>自学习</strong>的，即自动维护交换机表，即插即用 交换机缓存从每一个接口接收到的入帧的信息，若一定时间内没有再收到此地址的帧，则将该表项删除</p>
<h2 id="转发器，交换机，网桥，路由器，网关等？"><a href="#转发器，交换机，网桥，路由器，网关等？" class="headerlink" title="转发器，交换机，网桥，路由器，网关等？"></a>转发器，交换机，网桥，路由器，网关等？</h2><p><strong>转发器</strong>：物理层设备 <strong>交换机</strong>：数据链路层设备，基于MAC地址，提供数据帧的转发与过滤服务 <strong>网桥</strong>：数据链路层设备，提供将两个不同网段的网络连接起来的服务 <strong>路由器</strong>：网络层设备，基于IP地址，提供数据报的路由和转发服务 <strong>网关</strong>：网络层以上设备，提供一个网络与另一个网络连接的服务</p>
<p><strong>交换机与路由器的对比</strong></p>
<ul>
<li>交换机是第二层（数据链路层）设备，路由器是第三层（网络层）设备</li>
<li>交换机基于MAC地址，路由器基于IP地址</li>
<li>交换机是即插即用的，路由器不是，需要认为设置IP地址</li>
<li>交换机可能会产生广播风暴，路由器不会</li>
<li>交换机主要负责组建局域网，路由器主要负责将局域网连接起来，连入互联网</li>
<li>交换机求快，直接按目的MAC地址转发，路由器谋短，需要计算最小费用路径，然后转发</li>
<li>交换机主要用于规模较小的局域网，路由器主要用于规模较大的网络</li>
</ul>
<h2 id="TCP与UDP区别？"><a href="#TCP与UDP区别？" class="headerlink" title="TCP与UDP区别？"></a>TCP与UDP区别？</h2><ol>
<li>TCP提供面向连接的传输；UDP提供无连接的传输</li>
<li>TCP提供可靠的传输（有序，无差错，不丢失，不重复）； UDP提供不可靠的传输。</li>
<li>TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组；UDP是面向数据报的传输，没有分组开销。</li>
<li>TCP提供拥塞控制和流量控制机制；UDP不提供拥塞控制和 流量控制机制。</li>
<li>TCP只能是点对点的（一对一），UDP支持一对一、一对 多、多对一和多对多的交互通信。</li>
<li>TCP传输效率较低，UDP传输效率较高。</li>
</ol>
<p>应用场景：</p>
<p><img src="https://pic1.zhimg.com/80/v2-06bdd52997add27938607b33edea4068_1440w.webp" alt="img"></p>
<h2 id="HTTP中GET与POST区别？"><a href="#HTTP中GET与POST区别？" class="headerlink" title="HTTP中GET与POST区别？"></a>HTTP中GET与POST区别？</h2><table>
<thead>
<tr>
<th></th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody><tr>
<td>参数放置位置</td>
<td>url里面</td>
<td>请求头里面</td>
</tr>
<tr>
<td>安全性</td>
<td>差</td>
<td>好</td>
</tr>
<tr>
<td>长度限制</td>
<td>2048字符</td>
<td>无限制</td>
</tr>
<tr>
<td>被浏览器缓存</td>
<td>有缓存</td>
<td>无缓冲</td>
</tr>
<tr>
<td>浏览器访问</td>
<td>可以，支持刷新和回退</td>
<td>不可以</td>
</tr>
</tbody></table>
<h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别?"></a>HTTP和HTTPS的区别?</h2><p>由来：https解决了http的传输的安全问题，因为http传输的是明文，简单来说https=http+ssl进行加密传输，https是身份认证的网络协议</p>
<p>https两个作用：1.建立信息安全通道 2.网站的真实性</p>
<table>
<thead>
<tr>
<th></th>
<th>http</th>
<th>https</th>
</tr>
</thead>
<tbody><tr>
<td>证书</td>
<td>不需要</td>
<td>需要ca证书，需要费用</td>
</tr>
<tr>
<td>信息传输方式</td>
<td>明文</td>
<td>密文</td>
</tr>
<tr>
<td>连接方式</td>
<td>80端口</td>
<td>443端口</td>
</tr>
</tbody></table>
<h2 id="IPV4与IPV6的区别？"><a href="#IPV4与IPV6的区别？" class="headerlink" title="IPV4与IPV6的区别？"></a>IPV4与IPV6的区别？</h2><ol>
<li>IPv6将地址从32位（4B）扩大到128位（16B），更大的地址空间。</li>
<li>IPv6将IPv4的效验和字段彻底删除，以减小每跳的处理时间。</li>
<li>IPv6支持即插即用（即自动配置），不需要DHCP协议。</li>
<li>IPv6首部长度必须是8B的整数倍，IPv4首部是4B的整数倍。</li>
<li>IPv6将IPv4的可选字段移出首部，变成了扩展首部，成为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率。</li>
<li>IPv6取消了总长度字段，改用有效载荷长度字段。</li>
<li>IPv6只能在主机处分片，IPv4可以在路由器和主机处分片。</li>
<li>IPv6取消了协议字段，改成下一个首部字段。</li>
</ol>
<h2 id="输入网址到网页显示的整个流程"><a href="#输入网址到网页显示的整个流程" class="headerlink" title="输入网址到网页显示的整个流程"></a>输入网址到网页显示的整个流程</h2><p>第一步：首先你得在浏览器中输入网址，比如输入<a target="_blank" rel="noopener" href="http://www.baidu.com.其中www为主机,baidu为域名,com为类型.但是有网址不能直接找到对应的响应主机,必须把网址,即域名转化为ip地址./">www.baidu.com。其中www为主机，baidu为域名，com为类型。但是有网址不能直接找到对应的响应主机，必须把网址，即域名转化为ip地址。</a></p>
<p>第二步：进行DNS（Domain Name System，域名系统）查询，它的作用是将域名转化为具体的ip地址。</p>
<p>先谈一下DNS的结构：</p>
<p>（1）根域名服务器，全球只有13个不同ip地址的服务器，注意不是服务器只有13台，只是他们所代表的地址只有13个，也就是存在镜像服务器，一个地址可以对应多个镜像服务器。</p>
<p>（2）根域名服务器之下的顶级域名服务器，如com、net、cn、gov等。</p>
<p>（3）顶级域名服务器之下的权威服务器，比如baidu、facebook等。</p>
<p>（4）权威服务器之下的资源记录，比如www、ftp、mail等。</p>
<p>查询的过程如下：</p>
<p>（1）首先会在浏览器缓存中去查询，之前每浏览一个网站，浏览器都会在缓存中存有域名与ip地址的映射关系。不过缓存失效的时间不由浏览器决定，而由操作系统决定。</p>
<p>（2）浏览器缓存中查询不到后，之后会在系统缓存中查询，由浏览器发起一个系统调用，查询系统缓存中的数据。</p>
<p>（3）系统缓存中也查询不到后，将会去路由器缓存中查找。</p>
<p>（4）路由器缓存中也找不到的话，将会从本地DNS服务器的缓存中查找，本地服务器即用户自己配置的DNS服务器。</p>
<p>（5）如果本地的DNS服务器也找不到的话，本地DNS将会发送请求至根域名服务器，根域名服务器中没有相关缓存数据的时候，就会返回com顶级域名服务器的地址。然后本地DNS服务器再发送请求至com顶级域名服务器，com顶级域名服务器中查询不到的话，就会返回baidu权威服务器的地址，然后本地DNS服务器再发送请求至baidu权威服务器，baidu权威服务器就会返回www主机地址。（这是一种迭代的过程，还有一种递归的过程。即local至根域名，根域名不直接返回com地址，而是发送请求至com，com发送请求至baidu，baidu发送请求至www，www再返回给baidu，baidu返回给com，com再返回给local）至此，整个DNS查询步骤结束，现在浏览器拿到了域名对应的ip地址。</p>
<p>第三步：浏览器发送请求至服务器，假设我们现在输入的地址是<a target="_blank" rel="noopener" href="http://www.baidu.com,那么浏览器默认将网址改成这样的形式,即http//www.baidu.com%E3%80%82">www.baidu.com，那么浏览器默认将网址改成这样的形式，即http://www.baidu.com。</a></p>
<p>发送格式如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20181119155220971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkxOTAz,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>发现返回了307状态码，也就是临时重定向，需要我们重定向到location表明的地址，即<a target="_blank" rel="noopener" href="https://www.baidu.com.仔细观察,仅仅多了个s,也就是说http与https之间是有差别的,关于两个的区别,请移步我的另外一篇文章浅析http与https的区别/">https://www.baidu.com。仔细观察，仅仅多了个s，也就是说http与https之间是有差别的，关于两个的区别，请移步我的另外一篇文章浅析HTTP与HTTPS的区别</a></p>
<p>307与301、302本质上差不多，但是有细微的差别，简单来说是为了增强301与302的规范性。其他差别这里不做深究，可以参考HTTP状态码302、303和307的故事</p>
<p>第四步：浏览器向重定向后的地址发送请求</p>
<p>发送的请求格式如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20181119155117449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkxOTAz,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>可以看得出：</p>
<p>（1）Request Method表明请求方式是get。</p>
<p>（2）User-Agent，用户代理，表明所用浏览器的一些信息，包括内核，版本等。</p>
<p>（3）Connection:keep-alive表明需要服务器为之后的请求保持tcp连接</p>
<p>（4）Cookie中保存了一些与用户状态相关的数值，可以与session连用来跟踪会话，那么有关cookie与session的内容，可以参考我的另外一篇文章【计算机网络】Cookie与Session的区别</p>
<p>第五步：服务器处理http请求</p>
<p>服务器可以根据Cookie中的数据，通过遍历内存中的Session集合，从而判断用户的登录状态。如果用户未登录，则展示一些诸如首页的基本宣传数据。如果用户已经登录，通过解析get请求头、post请求体中的参数，查询数据库，返回用户相关数据，填充到视图中。并将此次处理完的内容通过相应的压缩算法，压缩成某个块。</p>
<p>第六步：服务器返回http响应</p>
<p>服务器返回的响应格式如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20181119155320648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkxOTAz,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>其中有些键值対表明：</p>
<p>（1）Content-Encoding的值是gzip，表明响应体使用了gzip方式压缩了，浏览器也需要使用gzip算法进行解压缩，解压缩响应体后，产生如下的内容</p>
<p><img src="https://img-blog.csdnimg.cn/20181119155809460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkxOTAz,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>（2）Content-Type的值是text/html，表明服务器需要浏览器将次内容以html文本的形式显示出来，而不是以文件形式去下载它</p>
<p>第七步：浏览器请求样式以及图片文件，用以渲染界面并显示给用户</p>
<p>浏览器解压缩响应体后，在界面显示的同时，下载css、png、gif等一些静态文件，这些静态文件可以被浏览器缓存，防止多次请求。很多公司将自己的静态文件托管在CDN上（Content Delivery Network，即内容分发网络），从CDN上加载大量静态文件，加快查找速度，减少原本网站的并发压力。</p>
<p>访问百度的静态文件有：（出去前两个与最长的那个）</p>
<p><img src="https://img-blog.csdnimg.cn/20181119161206112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkxOTAz,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>第八步：浏览器通过Ajax（Asynchronous Javascript And XML 异步 JavaScript 和 XML）</p>
<p>在传统的web应用，用户每发一次请求，用户的动作就会被阻塞，即在服务器返回响应之前，用户不可以进行其他的操作，只能等待响应。然后服务器会响应一个完整的html页面，浏览器再次进行渲染。哪怕是一个很小的一个请求，都会阻塞用户动作，以及刷新整个页面，极大地浪费了用户的时间和网络的带宽，也增加了服务器的压力。</p>
<p>Ajax出现之后，通过此技术发起的http请求，将不会阻塞用户的动作，服务器响应之后，页面会进行一个局部的刷新，也就是不会刷新整个页面，极大提高了页面加载与服务器处理的效率。当然Ajax也要自身的缺点，暴露了浏览器和服务器通信的具体逻辑，容易造成漏洞攻击。此外，Ajax没有后退机制，在一定程度上，用户的体验感降低。</p>
<p>百度界面显示出来后，百度又利用了ajax去请求我之前的搜索关键词，然后利用js填充到搜索框的下拉列表中，返回的数据如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20181119163508720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkxOTAz,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="三次握手问题："><a href="#三次握手问题：" class="headerlink" title="三次握手问题："></a>三次握手问题：</h2><p>见上面5.7、5.8中内容。</p>
<h1 id="常见名词："><a href="#常见名词：" class="headerlink" title="常见名词："></a>常见名词：</h1><h2 id="载波监听："><a href="#载波监听：" class="headerlink" title="载波监听："></a>载波监听：</h2><p>CSMA：Carrier Sense Multiple Access</p>
<p>任何站点要向公共介质发送信息时，首先要监听介质上是否有其他站点正在传送信息</p>
<p>如果通信介质上无载波，即没有被占用，则可以利用通信介质进行传送；</p>
<p>如果已监听到介质上有载波，即有其它站点正在传送信息，则必须等待介质平静之后才能进行传送的处理，这样就会使信道上的冲突大大减少。</p>
<h2 id="协议栈："><a href="#协议栈：" class="headerlink" title="协议栈："></a>协议栈：</h2><p>Protocol Stack，是计算机<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE?fromModule=lemma_inlink">网络协议</a>套件的一个具体的软件实现。协议套件中的一个协议通常是只为一个目的而设计的，这样可以使得设计更容易。因为每个协议模块通常都要和上下两个其他协议模块通信，它们通常可以想象成是协议栈中的层。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/" rel="tag">课程学习</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-MyFirstBlog"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/18/MyFirstBlog/"
    >MyFirstBlog</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/18/MyFirstBlog/" class="article-date">
  <time datetime="2023-09-18T03:15:00.000Z" itemprop="datePublished">2023-09-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Hello, My name is LightDust (not lightdust). </p>
<p>This is my first blog.</p>
<p>Next I will be posting a series of content on my blog.</p>
<p>If you are interested in this, then come along with me!</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9D%82%E9%A1%B9/" rel="tag">杂项</a></li></ul>

    </footer>
  </div>

    
 
   
  
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023
        <i class="ri-heart-fill heart_icon"></i> LightDust
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
      <li>
          <img src="/images/beian.png"></img>
          <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=01234567890123" target="_black" rel="nofollow">浙公网安备01234567890123号</a>
      </li>
        
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src=''></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="LightDust"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>