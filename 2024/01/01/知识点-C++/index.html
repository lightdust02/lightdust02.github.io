<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>知识点-C++ |  LightDust</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-知识点-C++"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  知识点-C++
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/01/%E7%9F%A5%E8%AF%86%E7%82%B9-C++/" class="article-date">
  <time datetime="2024-01-01T03:15:00.000Z" itemprop="datePublished">2024-01-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B0%B1%E4%B8%9A/">就业</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">16k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">57 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>记录 C++ 相关知识点。</p>
<p>会一直持续更新。</p>
<span id="more"></span>

<p>( 放几个Java学习网站在开头，不要问为什么 ^_^ )</p>
<p><a target="_blank" rel="noopener" href="https://topjavaer.cn/">主页 | Java学习&amp;面试指南-程序员大彬 (topjavaer.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/608060989">三天吃透Java面试八股文（2023最新整理） - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/531778558">(85 封私信 / 81 条消息) 背Java面试八股文有用嘛？ - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blinkfox.github.io/about/">关于 | 闪烁之狐 (blinkfox.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://zxh3032.github.io/">随便寻个地方’Blog (zxh3032.github.io)</a></p>
<h2 id="1-开始"><a href="#1-开始" class="headerlink" title="1. 开始"></a>1. 开始</h2><p>本文目的是整理面试常见的会问到的题目, 具体细节的学习需要参考 <em><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=C+++Primer&zhida_source=entity">C++ Primer</a></em> / <em>Effective C++</em> 系列书籍 / <em>Inside the C++ Object Model</em> 进行学习.</p>
<p>为了方便查阅, 补充了可能没有面试内容的一级标题. 这样一级标题可以和 <em>C++ Primer</em> 书籍保持一致.</p>
<h3 id="1-1-C-和-C-的区别"><a href="#1-1-C-和-C-的区别" class="headerlink" title="1.1. C 和 C++ 的区别"></a>1.1. C 和 C++ 的区别</h3><p>设计思想上:</p>
<ul>
<li>C++ 是面向对象的语言, C 是<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E8%AF%AD%E8%A8%80&zhida_source=entity">面向过程的语言</a></li>
</ul>
<p>语法上:</p>
<ul>
<li>C++ 具有封装/继承/多态三种特性.</li>
<li>C++ 相比 C, 增加了类型安全的功能, 比如<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&zhida_source=entity">强制类型转换</a>.</li>
<li>C++ 支持范式编程, 比如模板类/函数模板等.</li>
</ul>
<h2 id="2-变量和基本类型"><a href="#2-变量和基本类型" class="headerlink" title="2. 变量和基本类型"></a>2. 变量和基本类型</h2><h3 id="2-1-复合类型"><a href="#2-1-复合类型" class="headerlink" title="2.1. 复合类型"></a>2.1. 复合类型</h3><p>复合类型(compound type)是指基于其他类型定义的类型. 最常见的是引用和指针.</p>
<p>引用即别名: 引用(reference)为对象起了另外一个名字, 引用类型引用(refers to)另外一种类型.</p>
<ul>
<li>定义引用时, 程序把引用和它的初始值绑定在一起, 而不是将初始值拷贝给引用. 一旦初始化完成, 引用将和它的初始值对象一直绑定在一起. 因为无法令引用重新绑定到另外一个对象, 因此引用必须初始化.</li>
<li>因为引用不是一个对象, 所以不能定义引用的引用.</li>
</ul>
<p>指针(pointer)是指向(point to)另外一种类型的复合类型.</p>
<ul>
<li>指针无需在定义时赋初值.</li>
<li>指针本身就是一个对象, 允许对指针赋值和拷贝, 而且在指针的生命周期内它可以先后指向几个不同的对象.</li>
</ul>
<p>表 2.1 指针与数组的区别</p>
<table>
<thead>
<tr>
<th>指针</th>
<th>数组</th>
</tr>
</thead>
<tbody><tr>
<td>保存数据的地址.</td>
<td>保存数据.</td>
</tr>
<tr>
<td>间接访问数据, 首先获得指针的内容, 然后将其作为地址, 从该地址中提取数据.</td>
<td>直接访问数据.</td>
</tr>
<tr>
<td>通常用于动态的数据结构.</td>
<td>通常用于固定数目且数据类型相同的元素.</td>
</tr>
<tr>
<td>通过<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=malloc&zhida_source=entity">malloc</a>分配内存, free释放内存.</td>
<td>隐式的分配和删除.</td>
</tr>
<tr>
<td>通常指向匿名数据, 操作匿名函数.</td>
<td>自身即为数据名.</td>
</tr>
<tr>
<td>指针取地址得到的是指针变量自身的地址.</td>
<td>数组名取地址得到的是数组名所指元素的地址(数组的第一个元素的地址).</td>
</tr>
<tr>
<td>指针能更改名字</td>
<td>数组是固定大小, 数组一经定义, 就不能改变数组名.</td>
</tr>
</tbody></table>
<h3 id="2-2-const限定符"><a href="#2-2-const限定符" class="headerlink" title="2.2. const限定符"></a>2.2. <code>const</code>限定符</h3><p><strong>2.2.1. 作用</strong></p>
<ul>
<li>修饰变量: 表明该变量的值不可以被改变.</li>
<li>修饰指针: 区分指向常量的指针和<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88&zhida_source=entity">常量指针</a>.</li>
<li>修饰引用: 用于形参, 既避免了拷贝, 又避免了函数对值的修改.</li>
<li>修饰<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0&zhida_source=entity">成员函数</a>: 表示函数不能修改成员变量(实际上是修饰<code>this</code>指针)</li>
</ul>
<p>补充:</p>
<ul>
<li>对于局部对象,常量存放在栈区;</li>
<li>对于全局对象, 常量存放在全局/静态存储区;</li>
<li>对于字面值常量, 常量存放在<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8%E5%8C%BA&zhida_source=entity">常量存储区</a>(代码段).</li>
</ul>
<p><strong>2.2.2. 指向常量的指针 VS 常量指针</strong></p>
<p>参考 <em>C++ Primer</em> 2.4.2 指针和<code>const</code>:</p>
<ul>
<li><p>指向常量的指针(pointer to const):</p>
</li>
<li><ul>
<li>具有只能够读取内存中数据, 却不能够修改内存中数据的属性的指针(底层 const).</li>
<li><code>const int * p;</code>或者<code>int const * p;</code></li>
</ul>
</li>
<li><p>常量指针(const pointer): 常量指针是指指针所指向的位置不能改变, 即指针本身是一个常量(顶层 const), 但是指针所指向的内容可以改变.</p>
</li>
<li><ul>
<li>常量指针必须在声明的同时对其初始化, 不允许先声明一个<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F&zhida_source=entity">指针常量</a>随后再对其赋值, 这和声明一般的常量是一样的.</li>
<li><code>int * const p = &amp;a;</code></li>
</ul>
</li>
</ul>
<p><strong>2.2.3. <code>cosntexpr</code></strong></p>
<ul>
<li><p>常量表达式(const expression)是指值不会改变并且在编译过程就能得到计算结果的表达式.</p>
</li>
<li><p>一般来说, 如果认定变量是一个常量表达式, 那就把它声明成<code>constexpr</code>类型.</p>
</li>
<li><p>一个<code>constexpr</code>指针的初始值必须是<code>nullptr</code>或者<code>0</code>, 或者是存储于某个固定地址中的对象.</p>
</li>
<li><p><code>constexpr</code>函数是指能用于常量表达式的函数.</p>
</li>
<li><ul>
<li>函数的返回类型及所有的形参的类型都得是字面值类型.</li>
<li>函数体中必须有且只有一条<code>return</code>语句.</li>
</ul>
</li>
</ul>
<p><strong>2.2.4. <code>#define</code> VS <code>const</code></strong></p>
<table>
<thead>
<tr>
<th>#define</th>
<th>const</th>
</tr>
</thead>
<tbody><tr>
<td>宏定义, 相当于字符替换</td>
<td>常量声明</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8&zhida_source=entity">预处理器</a>处理</td>
<td>编译器处理</td>
</tr>
<tr>
<td>无类型安全检查</td>
<td>有类型安全检查</td>
</tr>
<tr>
<td>不分配内存</td>
<td>要分配内存</td>
</tr>
<tr>
<td>存储在代码段(.text)</td>
<td>存储在数据段(.data, .bbs)</td>
</tr>
<tr>
<td>可通过#undef取消</td>
<td>不可取消</td>
</tr>
</tbody></table>
<h2 id="3-字符串、向量和数组"><a href="#3-字符串、向量和数组" class="headerlink" title="3. 字符串、向量和数组"></a>3. 字符串、向量和数组</h2><h2 id="4-表达式"><a href="#4-表达式" class="headerlink" title="4. 表达式"></a>4. 表达式</h2><h3 id="4-1-右值"><a href="#4-1-右值" class="headerlink" title="4.1. 右值"></a>4.1. 右值</h3><p>C++的表达式要不然是右值(rvalue), 要不然是左值(lvalue). 这两个名词是从 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=C+%E8%AF%AD%E8%A8%80&zhida_source=entity">C 语言</a>继承过来的, 原本是为了帮助记忆: 左值可以位于赋值语句的左侧, 右值则不能.</p>
<p>当一个对象被用做右值的时候, 用的是对象的值(内容); 当对象被用做左值的时候, 用的是对象的身份(在内存中的位置).</p>
<h3 id="4-2-i-i"><a href="#4-2-i-i" class="headerlink" title="4.2. ++i/i++"></a>4.2. <code>++i</code>/<code>i++</code></h3><p>前置版本<code>++i</code>: 首先将运算对象加 1, 然后将改变后的对象作为求值结果.</p>
<p>后置版本<code>i++</code>: 也会将运算对象加 1, 但是求解结果是运算对象改变之前的那个值的副本.</p>
<p>以下摘录自 <em>More Effective C++</em> Item 6:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prefix form(++i): increment and fetch</span></span><br><span class="line">UPInt&amp;  UPInt::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    *<span class="keyword">this</span> +=<span class="number">1</span>；        <span class="comment">// increment</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>；     <span class="comment">// fetch</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// postfix form(i++): fetch and increment</span></span><br><span class="line"><span class="type">const</span> UPInt UPInt::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> UpInt oldValue = *<span class="keyword">this</span>; <span class="comment">// fetch</span></span><br><span class="line">    ++(*<span class="keyword">this</span>);                    <span class="comment">// increment</span></span><br><span class="line">    <span class="keyword">return</span> oldValue；             <span class="comment">// return what was fetched</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-sizeof运算符"><a href="#4-3-sizeof运算符" class="headerlink" title="4.3. sizeof运算符"></a>4.3. <code>sizeof</code>运算符</h3><p><strong>4.3.1. 普通变量执行<code>sizeof</code></strong></p>
<p><code>sizeof</code>运算符的结果部分地依赖于其作用的类型:</p>
<ul>
<li>对<code>char</code>或者类型为<code>char</code>的表达式执行<code>sizeof</code>运算, 结果得 1.</li>
<li>对引用类型执行<code>sizeof</code>运算得到被引用对象所占空间的大小.</li>
<li>对指针执行<code>sizeof</code>运算得到指针本身所占空间的大小.</li>
<li>对解引用指针执行<code>sizeof</code>运算得到指针指向的对象所占空间的大小.</li>
<li>对数组执行<code>sizeof</code>运算得到整个数组所占空间的大小, 等价于对数组中所<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E6%9C%89%E5%85%83&zhida_source=entity">有元</a>素各执行一次<code>sizeof</code>运算并将所得结果求和.</li>
<li>对<code>string</code>对象或<code>vector</code>对象执行<code>sizeof</code>运算只返回该类型固定部分的大小.</li>
</ul>
<p><strong>4.3.2. 类执行<code>sizeof</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; <span class="built_in">B</span>(); ~<span class="built_in">B</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123; <span class="built_in">C</span>(); <span class="keyword">virtual</span> ~<span class="built_in">C</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123; <span class="built_in">D</span>(); ~<span class="built_in">D</span>() &#123;&#125; <span class="type">int</span> d; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> &#123; <span class="built_in">E</span>(); ~<span class="built_in">E</span>() &#123;&#125; <span class="type">static</span> <span class="type">int</span> e; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; std::endl; <span class="comment">// 输出结果为1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; std::endl; <span class="comment">// 输出结果为1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(C) &lt;&lt; std::endl; <span class="comment">// 输出结果为8,实例中有一个指向虚函数表的指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(D) &lt;&lt; std::endl; <span class="comment">// 输出结果为4,int占4个字节</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(E) &lt;&lt; std::endl; <span class="comment">// 输出结果为1,static不算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个空类型, 里面没有成员变量和成员函数, 求<code>sizeof</code>结果为 1. 空类型的实例中不包括任何信息, 本来求<code>sizeof</code>得到0, 但是当我们声明该类型的实例的时候, 它必须在内存中占有一定的空间, 否则则无法使用这些实例, 至于占用多少内存, 由编译器决定, 一般有一个<code>char</code>类新的内存.</li>
<li>如果在该类型中添加一个构造函数和析构函数, 再对该类型求<code>sizeof</code>结果仍为 1. 调用构造函数和析构函数只需要知道函数的地址即可, 而这些函数的类型只与类型相关, 而与类型的实例无关, 编译器也不会因为这两个函数在实例内添加任何额外的信息.</li>
<li>如果把析构函数标记为虚函数, 就会为该类型生成虚函数表, 并在该类型的每一个实例中添加一个指向虚函数表的指针. 在 32 位的机器上, 一个指针占 4 字节的空间, 因此求<code>sizeof</code>得到 4; 在 64 位机器上, 一个指针占 8 字节的空间, 因此求<code>sizeof</code>得到 8.</li>
</ul>
<h3 id="4-4-显式转换"><a href="#4-4-显式转换" class="headerlink" title="4.4. 显式转换"></a>4.4. <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2&zhida_source=entity">显式转换</a></h3><ul>
<li><code>static_cast</code>: 任何具有明确定义的类型转换, 只要不包含底层<code>const</code>, 都可以使用<code>static_cast</code>.</li>
<li><code>dynamic_cast</code>: 用于(动态)多态类型转换. 只能用于含有虚函数的类, 用于类层次间的向上向下转化.</li>
<li><code>const_cast</code>: 去除”指向常量的指针”的<code>const</code>性质.</li>
<li><code>reinterpret_cast</code>: 为运算对象的位模式提供较低层次的重新解释, 常用于<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88&zhida_source=entity">函数指针</a>的转换.</li>
</ul>
<h2 id="5-语句"><a href="#5-语句" class="headerlink" title="5. 语句"></a>5. 语句</h2><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h2><h3 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1. 函数基础"></a>6.1. 函数基础</h3><p><strong>6.1.1. 形参和<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%AE%9E%E5%8F%82&zhida_source=entity">实参</a></strong></p>
<p>实参是形参的初始值.</p>
<p><strong>6.1.2. <code>static</code></strong></p>
<ul>
<li><p>修饰局部变量: 使得被修饰的变量成为<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F&zhida_source=entity">静态变量</a>, 存储在静态区. 存储在静态区的数据生命周期与程序相同, 在<code>main</code>函数之前初始化, 在程序退出时销毁. 默认初始化为 0.</p>
</li>
<li><p>修饰全局变量: 限制了链接属性, 使得全局变量只能在声明它的源文件中访问.</p>
</li>
<li><p>修饰普通函数: 使得函数只能在声明它的源文件中访问.</p>
</li>
<li><p>修饰类的成员变量和成员函数: 使其只属于类而不是属于某个对象. 对多个对象来说, 静态数据成员只存储一处, 供所有对象共用.</p>
</li>
<li><ul>
<li>静态成员调用格式<code>&lt;类名&gt;::&lt;静态成员&gt;</code></li>
<li>静态成员函数调用格式<code>&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;)</code></li>
</ul>
</li>
</ul>
<h3 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2. 参数传递"></a>6.2. 参数传递</h3><p>指针参数传递本质上是值传递, 它所传递的是一个地址值.</p>
<p>一般情况下, 输入用传值或者传<code>const reference</code>. 输出传引用(或者指针).</p>
<h3 id="6-3-内联函数"><a href="#6-3-内联函数" class="headerlink" title="6.3. 内联函数"></a>6.3. 内联函数</h3><p><strong>6.3.1. 使用</strong></p>
<p>将函数指定为内联函数(<code>inline</code>), 通常就是将它在每个调用点上”内联地”展开.</p>
<p>一般来说, 内联机制用于优化规模较小(<em>Google C++ Style</em> 建议 10 行以下)、流程直接、频繁调用的函数.</p>
<p>在类声明中定义的函数, 除了虚函数的其他函数都会自动隐式地当成内联函数.</p>
<p><strong>6.3.2. 编译器对<code>inline</code>函数的处理步骤</strong></p>
<ol>
<li>将<code>inline</code>函数体复制到<code>inline</code>函数调用点处;</li>
<li>为所用<code>inline</code>函数中的局部变量分配内存空间;</li>
<li>将<code>inline</code>函数的的输入参数和返回值映射到调用方法的局部变量空间中;</li>
<li>如果<code>inline</code>函数有多个返回点, 将其转变为<code>inline</code>函数代码块末尾的分支(使用 GOTO).</li>
</ol>
<p><strong>6.3.3. 优缺点</strong></p>
<p>优点:</p>
<ol>
<li>内联函数同<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%AE%8F%E5%87%BD%E6%95%B0&zhida_source=entity">宏函数</a>一样将在被调用处进行代码展开, 省去了<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%8F%82%E6%95%B0%E5%8E%8B%E6%A0%88&zhida_source=entity">参数压栈</a>、栈帧开辟与回收, 结果返回等, 从而提高程序运行速度.</li>
<li>内联函数相比宏函数来说, 在代码展开时, 会做安全检查或自动类型转换(同普通函数), 而宏定义则不会.</li>
<li>在类中声明同时定义的成员函数, 自动转化为内联函数, 因此内联函数可以访问类的成员变量, 宏定义则不能.</li>
<li>内联函数在运行时可调试, 而宏定义不可以.</li>
</ol>
<p>缺点:</p>
<ol>
<li>代码膨胀. 内联是以代码膨胀(复制)为代价, 消除函数调用带来的开销. 如果执行函数体内代码的时间, 相比于函数调用的开销较大, 那么效率的收获会很少. 另一方面, 每一处内联函数的调用都要复制代码, 将使程序的总代码量增大, 消耗更多的内存空间.</li>
<li><code>inline</code>函数无法随着函数库升级而升级. <code>inline</code>函数的改变需要重新编译, 不像<code>non-inline</code>可以直接链接.</li>
<li>是否内联, 程序员不可控. 内联函数只是对编译器的建议, 是否对函数内联, 决定权在于编译器.</li>
</ol>
<h3 id="6-4-返回类型和return语句"><a href="#6-4-返回类型和return语句" class="headerlink" title="6.4. 返回类型和return语句"></a>6.4. 返回类型和<code>return</code>语句</h3><p>调用一个返回引用的函数得到左值, 其他返回类型得到右值.</p>
<h3 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5. 特殊用途语言特性"></a>6.5. 特殊用途语言特性</h3><p><strong>6.5.1. 调试帮助</strong></p>
<p><code>assert</code>是一种预处理器宏. 使用一个表达式作为它的条件:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(expr);</span><br></pre></td></tr></table></figure>

<p>首先对<code>expr</code>求值, 如果表达式为<code>false</code>. <code>assert</code>输出信息并终止程序的执行. 如果表达式为<code>true</code>. <code>assert</code>什么也不做.</p>
<h3 id="6-6-函数指针"><a href="#6-6-函数指针" class="headerlink" title="6.6. 函数指针"></a>6.6. 函数指针</h3><p>函数指针指向的是函数而非对象. 和其他指针一样, 函数指针指向某种特定类型. 函数的类型由它的返回类新和形参共同决定, 与函数名无关.</p>
<p>C 在编译时, 每一个函数都有一个入口地址, 该入口地址就是函数指针所指向的地址.</p>
<p>有了指向函数的指针变量后,可用该指针变量调用函数,就如同用指针变量可引用其他类型变量一样</p>
<p>用途: 调用函数和做函数的参数, 比如<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0&zhida_source=entity">回调函数</a>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">fun</span><span class="params">(<span class="type">char</span> * p)</span>  </span>&#123;…&#125;  <span class="comment">// 函数fun</span></span><br><span class="line"><span class="type">char</span> * (*pf)(<span class="type">char</span> * p);    <span class="comment">// 函数指针pf</span></span><br><span class="line">pf = fun;                  <span class="comment">// 函数指针pf指向函数fun</span></span><br><span class="line"><span class="built_in">pf</span>(p);                     <span class="comment">// 通过函数指针pf调用函数fun</span></span><br></pre></td></tr></table></figure>

<h2 id="7-类"><a href="#7-类" class="headerlink" title="7. 类"></a>7. 类</h2><h3 id="7-1-定义抽象数据类型"><a href="#7-1-定义抽象数据类型" class="headerlink" title="7.1. 定义抽象数据类型"></a>7.1. 定义<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&zhida_source=entity">抽象数据类型</a></h3><p><strong>7.1.1. <code>this</code>指针</strong></p>
<ul>
<li><p><code>this</code>指针是一个隐含于每一个<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0&zhida_source=entity">非静态成员函数</a>中的特殊指针. 它指向调用该成员函数的那个对象.</p>
</li>
<li><p><code>this</code>的目的总是指向”这个”对象, 所以<code>this</code>是一个常量指针, 被隐含地声明为:<code>ClassName *const this</code>, 这意味着不能给<code>this</code>指针赋值;</p>
</li>
<li><p>在<code>ClassName</code>类的<code>const</code>成员函数中, <code>this</code>指针的类型为:<code>const ClassName* const</code>, 这说明不能对<code>this</code>指针所指向对象进行修改.</p>
</li>
<li><p>当对一个对象调用成员函数时, 编译程序先将对象的地址赋给<code>this</code>指针, 然后调用成员函数, 每次成员函数存取数据成员时, 都隐式使用<code>this</code>指针.</p>
</li>
<li><p>当一个成员函数被调用时, 自动向它传递一个隐含的参数, 该参数是一个指向这个成员函数所在的对象的指针.</p>
</li>
<li><p><code>this</code>并不是一个常规变量, 而是个右值, 所以不能取得<code>this</code>的地址(不能<code>&amp;this</code>).</p>
</li>
<li><p>在以下场景中, 经常需要显式引用<code>this</code>指针:</p>
</li>
<li><ul>
<li>为实现对象的链式引用;</li>
<li>为避免对同一对象进行赋值操作;</li>
<li>在实现一些数据结构时, 如<code>list</code>.</li>
</ul>
</li>
</ul>
<p><strong>7.1.2. <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0&zhida_source=entity">拷贝函数</a></strong></p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/u010700335/article/details/39830425">C++深拷贝与浅拷贝</a></li>
<li>在未定义显示拷贝构造函数的情况下, 系统会调用默认的拷贝函数——即浅拷贝, 它能够完成成员的一一复制. 当数据成员中没有指针时, 浅拷贝是可行的; 但当数据成员中有指针时, 如果采用简单的浅拷贝, 则两类中的两个指针将指向同一个地址, 当对象快结束时, 会调用两次析构函数, 而导致指针悬挂现象, 所以此时必须采用深拷贝.</li>
<li>深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据, 从而也就解决了指针悬挂的问题. 简而言之, 当数据成员中有指针时, 必须要用深拷贝.</li>
</ul>
<p><strong>7.1.3. 析构函数</strong></p>
<p>(TODO: 整理析构函数的特性)</p>
<ul>
<li>析构顺序与构造函数的构造顺序相反.</li>
<li>当对象结束生命周期时, 系统会自动执行析构函数.</li>
<li>析构函数声明时在函数名前加取反符~, 不带任何参数, 也没有返回值.</li>
<li>如果用户没有声明析构函数, 系统会自动生成一个缺省的析构函数.</li>
<li>如果类中有指针, 且在使用的过程中动态申请了内存, 那么需要显示构造析构函数, 在销毁类之前, 释放掉申请的内存空间, 避免<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F&zhida_source=entity">内存泄漏</a>.</li>
</ul>
<h3 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2. 访问控制与封装"></a>7.2. 访问控制与封装</h3><p><strong>7.2.1. <code>public</code>/<code>private</code>/<code>protected</code></strong></p>
<ul>
<li>定义在<code>public</code>说明符之后的成员在整个程序内可被访问, <code>public</code>成员定内的接口.</li>
<li>定义在<code>private</code>说明符之后的成员可以被<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0&zhida_source=entity">类的成员函数</a>访问, 但是不能被使用该类的代码访问, <code>private</code>部分封装了(即隐藏了)类的实现细节.</li>
<li>基类希望它的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E6%B4%BE%E7%94%9F%E7%B1%BB&zhida_source=entity">派生类</a>有权访问该成员, 同时禁止其他用户访问. 我们用受保护的(<code>protected</code>)访问运算符说明这样的成员.</li>
</ul>
<p><strong>7.2.2. <code>struct</code>和<code>class</code>的区别</strong></p>
<ul>
<li><code>struct</code>与<code>class</code>定义的唯一区别就是默认的访问权限(<code>struct</code>默认是<code>public</code>, <code>class</code>默认是<code>private</code>).</li>
<li>使用习惯上, 只有少量成员变量的的用<code>struct</code>定义.</li>
</ul>
<p><strong>7.2.3. 友元</strong></p>
<p>类可以允许其他类或者函数访问它的非公有成员, 方法是令其他类或者函数成为它的有元(<code>friend</code>).</p>
<h3 id="7-3-构造函数再探"><a href="#7-3-构造函数再探" class="headerlink" title="7.3. 构造函数再探"></a>7.3. 构造函数再探</h3><p><strong>7.3.1. 初始化顺序</strong></p>
<p>成员变量的初始化顺序与它们在类定义中的出现顺序一致: 构造函数初始值列表中初始值的前后位置关系不会影响</p>
<p><strong>7.3.2. <code>explicit</code></strong></p>
<ul>
<li>用于类的构造函数, 阻止其执行隐式类型转换, 但是仍可以被用来进行显式类型转换.</li>
</ul>
<h2 id="8-I-O-库"><a href="#8-I-O-库" class="headerlink" title="8. I/O 库"></a>8. I/O 库</h2><h2 id="9-顺序容器"><a href="#9-顺序容器" class="headerlink" title="9. 顺序容器"></a>9. 顺序容器</h2><h3 id="9-1-容器库概览"><a href="#9-1-容器库概览" class="headerlink" title="9.1. 容器库概览"></a>9.1. 容器库概览</h3><p><strong>9.1.1. <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E8%BF%AD%E4%BB%A3%E5%99%A8&zhida_source=entity">迭代器</a></strong></p>
<ul>
<li>迭代器(Iterator)模式又称游标(Cursor)模式, 用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示.</li>
<li>迭代器本质上是类模板, 只是表现地像指针.</li>
</ul>
<h3 id="9-2-顺序容器操作"><a href="#9-2-顺序容器操作" class="headerlink" title="9.2. 顺序容器操作"></a>9.2. 顺序容器操作</h3><p><strong>9.2.1. <code>emplace</code></strong></p>
<p>当调用<code>push</code>或<code>insert</code>成员函数时, 我们将元素类型的对象传递给它们, 这些对象被拷贝到容器中. 而当我们调用一个<code>emplace</code>成员函数时, 则是将参数传递给元素类型的构造函数. <code>emplace</code>成员使用这些参数在容器管理的内存空间中直接构造元素.</p>
<p><strong>9.2.2. <code>resize</code>/<code>reserve</code></strong></p>
<ul>
<li><code>resize</code>: 改变容器内含有元素的数量.</li>
<li><code>reserve</code>: 改变容器的最大容量.</li>
</ul>
<p><strong>9.2.3. 容器操作可能使迭代器失效</strong></p>
<p>在向容器中添加元素后:</p>
<ul>
<li>如果容器是<code>vector</code>或<code>string</code>, 且存储空间被重新分配, 则指向容器的迭代器, 指针和引用都会失效.</li>
<li>对于<code>deque</code>, 插入到除首尾位置之外的任何位置都会导致迭代器指针和引用失效.</li>
<li>对于<code>list</code>, 指向容器的迭代器指针和引用仍然有效.</li>
</ul>
<p>从容器删除元素后:</p>
<ul>
<li>对于<code>list</code>, 指向容器的迭代器指针和引用仍然有效.</li>
<li>对于<code>deque</code>, 在首尾之外的任何位置删除元素, 其他元素的迭代器也会失效.</li>
<li>对于<code>vector</code>或<code>string</code>, 被删元素之前的迭代器仍有效, 尾后迭代器失效.</li>
</ul>
<p>对于<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8&zhida_source=entity">关联式容器</a>(如<code>std::set</code> / <code>std::map</code>), 插入元素不会使任何迭代器失效.</p>
<p>对于无序关联式容器(如<code>std::unordered_set</code> / <code>std::unordered_map</code>), 插入元素之后如果发生了 Rehash(新元素的个数大于<code>max_load_factor() * bucket_count()</code>), 则所有迭代器将失效</p>
<h3 id="9-3-vector"><a href="#9-3-vector" class="headerlink" title="9.3. vector"></a>9.3. <code>vector</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态申请数组</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用new申请一个一维数组.访问p_arr[i].</span></span><br><span class="line"><span class="type">int</span>* p_arr = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line"><span class="comment">//使用new申请一个二维数组.访问:p_arr[i][j].</span></span><br><span class="line"><span class="built_in">int</span>(*p_arr)[N] = <span class="keyword">new</span> <span class="type">int</span>[M][N];</span><br><span class="line"><span class="comment">//一维数组转化为二维数组.访问:p_arr[i*N+j].</span></span><br><span class="line"><span class="type">int</span>* p_arr = <span class="keyword">new</span> <span class="type">int</span>[M*N];</span><br><span class="line"><span class="comment">//指向指针的指针(指向一维指针数组).访问p[i][j]</span></span><br><span class="line"><span class="type">int</span>** p_arr = <span class="keyword">new</span> <span class="type">int</span>* [M]</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    p_arr[i] = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line"><span class="comment">//回收内存</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">	<span class="keyword">delete</span> []p_arr[i];</span><br><span class="line"><span class="keyword">delete</span> []p_arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用vector申请一个一维数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v_arr</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v_arr&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//使用vector申请一个二维数组, 如果不初始化, 使用[]会报错</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v_arr</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v_arr = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一维数组作为函数参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span>* a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> a[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> a[N])</span></span>;</span><br><span class="line"><span class="comment">//二维数组作为函数参数,他们合法且等价</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> a[M][N])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> a[][N])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> (*a)[N])</span></span></span><br></pre></td></tr></table></figure>

<h3 id="9-4-string"><a href="#9-4-string" class="headerlink" title="9.4. string"></a>9.4. <code>string</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span></span><br><span class="line"><span class="function">string s2 </span>= s.<span class="built_in">substring</span>(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// s2 = hello</span></span><br><span class="line">string s3 = s.<span class="built_in">substring</span>(<span class="number">6</span>);    <span class="comment">// s3 = world</span></span><br><span class="line">string s4 = s.<span class="built_in">substring</span>(<span class="number">6</span>, <span class="number">11</span>);<span class="comment">// s4 = world</span></span><br><span class="line">string s5 = s.<span class="built_in">substring</span>(<span class="number">12</span>);   <span class="comment">// 抛出一个out_of_range异常</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isalpha</span>(ch); <span class="comment">//判断一个字符是否是字母</span></span><br><span class="line"><span class="built_in">isalnum</span>(ch); <span class="comment">//判断一个字符是数字或字母</span></span><br><span class="line"><span class="built_in">tolower</span>(ch); <span class="comment">//将字母转化成小写</span></span><br><span class="line"><span class="built_in">toupper</span>(ch); <span class="comment">//将字母转化为大写</span></span><br><span class="line"></span><br><span class="line">string str = <span class="built_in">to_string</span>(num); <span class="comment">//将数字转换成字符串</span></span><br></pre></td></tr></table></figure>



<h3 id="9-5-vector对象是如何增长的"><a href="#9-5-vector对象是如何增长的" class="headerlink" title="9.5. vector对象是如何增长的"></a>9.5. <code>vector</code>对象是如何增长的</h3><p>当不得不获取新的内存空间时, <code>vector</code>和<code>string</code>的实现通常会分配一个比新的空间需求更大的内存空间. 容器预留这些空间作为备用, 可以用来保存更多的新元素. 这样, 就不需要每次添加新元素都重新分配容器的内存空间了.</p>
<ul>
<li><p><code>capacity</code>操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素. <code>reserve</code>操作允许我们通知容器它应该准备保存多少个元素.</p>
</li>
<li><p>初始时刻<code>vector</code>的<code>capacity</code>为 0, 塞入第一个元素后<code>capacity</code>增加为 1.</p>
</li>
<li><p>不同的编译器实现的扩容方式不一样, <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=VS2015&zhida_source=entity">VS2015</a> 中以 1.5 倍扩容, GCC以 2 倍扩容.</p>
</li>
<li><ul>
<li>从空间上分析, 扩容因子越大, 意味着预留空间越大, 浪费的空间也越多, 所以从空间考虑, 扩容因子因越小越好.</li>
<li>从时间上分析, 如果预留空间不足的话, 就需要重新开辟一段空间, 把原有的数据复制到新空间, 如果扩容因子无限大的话, 那显然就不再需要额外开辟空间了. 所以时间角度看, 扩容因子越大越好.</li>
</ul>
</li>
</ul>
<h3 id="9-6-容器适配器"><a href="#9-6-容器适配器" class="headerlink" title="9.6. 容器适配器"></a>9.6. 容器适配器</h3><p>除了顺序容器外, <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E6%A0%87%E5%87%86%E5%BA%93&zhida_source=entity">标准库</a>还定义了三个顺序容器适配器: <code>stack</code>、<code>queue</code>和<code>priority_queue</code>.</p>
<p>本质上, 一个适配器是一种机制, 能使某种事物的行为看起来像另外一种事物一样.</p>
<p>默认情况下, <code>stack</code>和<code>queue</code>是基于<code>deque</code>实现的, <code>priority_queue</code>是在<code>vector</code>之上实现的.</p>
<p><strong>9.6.1. <code>priority_queue</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::priority_queue&lt;<span class="type">int</span>&gt; q1; <span class="comment">// 默认大根堆</span></span><br><span class="line">std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt;</span><br><span class="line">    <span class="built_in">q2</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>()); <span class="comment">// 小根堆</span></span><br><span class="line"><span class="comment">// 使用lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">int</span> left, <span class="type">int</span> right) &#123; <span class="built_in">return</span> (left ^ <span class="number">1</span>) &lt; (right ^ <span class="number">1</span>); &#125;;</span><br><span class="line">std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q3</span>(cmp);</span><br></pre></td></tr></table></figure>



<h2 id="10-泛型算法"><a href="#10-泛型算法" class="headerlink" title="10. 泛型算法"></a>10. 泛型算法</h2><h3 id="10-1-lambda-表达式"><a href="#10-1-lambda-表达式" class="headerlink" title="10.1. lambda 表达式"></a>10.1. lambda 表达式</h3><p>一个 lambda 表达式表示一个可调用的代码单元. 我们可以将其理解为一个未命名的内联函数. 一个 lambda 表达式具有如下形式:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list) -&gt; <span class="keyword">return</span> type &#123;function body&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>capture list</code>(捕获列表)是一个 lambda 所在函数中定义的局部变量的列表(通常为空); <code>return type</code>, <code>parameter list</code>和<code>function body</code>与任何普通函数一样, 分别表示返回类型、<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8&zhida_source=entity">参数列表</a>和函数体. 但是与普通函数不同, lambda 必须使用尾置返回来制定返回类新.</p>
<p>我们可以忽略参数列表和返回类型, 但必须包含捕获列表和函数体:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] &#123;<span class="keyword">return</span> <span class="number">42</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="11-关联容器"><a href="#11-关联容器" class="headerlink" title="11. 关联容器"></a>11. 关联容器</h2><ul>
<li><code>map</code>: 关键字-值对; <code>set</code>: 关键字即值.</li>
<li><code>map</code>: 按关键字有序保存元素(底层为红黑树); <code>unordered_map</code>: 无序集合(底层为哈系表).</li>
<li><code>map</code>: 关键字不可重复出现; <code>multimap</code>: 关键字可重复出现.</li>
</ul>
<h2 id="12-动态内存"><a href="#12-动态内存" class="headerlink" title="12. 动态内存"></a>12. 动态内存</h2><h3 id="12-1-智能指针"><a href="#12-1-智能指针" class="headerlink" title="12.1. 智能指针"></a>12.1. <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&zhida_source=entity">智能指针</a></h3><p>智能指针的行为类似常规指针, 重要的区别在于它负责自动释放所指向的对象.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr</span><br></pre></td></tr></table></figure>

<ul>
<li>允许多个指针指向同一个对象.</li>
<li>我们可以认为每个<code>shared_ptr</code>都有一个关联的计数器, 通常称其为<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0&zhida_source=entity">引用计数</a>. 一旦一个<code>shared_ptr</code>的计数器变为 0, 他就会自动释放自己所管理的对象.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr</span><br></pre></td></tr></table></figure>

<ul>
<li>“独占”所指向的对象.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weak_ptr</span><br></pre></td></tr></table></figure>

<ul>
<li><code>weak_ptr</code>是一种<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%BC%B1%E5%BC%95%E7%94%A8&zhida_source=entity">弱引用</a>, 指向<code>shared_ptr</code>所管理的对象.</li>
<li>可打破环状引用(cycles of references, 两个其实已经没有被使用的对象彼此相互指向, 使之看似还在 “被使用” 的状态)的问题.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make_shared</span><br></pre></td></tr></table></figure>

<ul>
<li><code>make_shared</code> 在动态内存中分配一个对象并初始化它, 返回指向此对象的<code>shared_ptr</code>.</li>
</ul>
<h2 id="13-拷贝控制"><a href="#13-拷贝控制" class="headerlink" title="13. 拷贝控制"></a>13. 拷贝控制</h2><h3 id="13-1-对象移动"><a href="#13-1-对象移动" class="headerlink" title="13.1. 对象移动"></a>13.1. 对象移动</h3><ul>
<li><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8&zhida_source=entity">右值引用</a>: 所谓右值引用就是必须绑定到右值的引用. 我们通过<code>&amp;&amp;</code>而不是<code>&amp;</code>来获得右值引用. 右值引用有一个重要的性质: 只能绑定到一个将要销毁的对象.</li>
<li>左值持久, 右值短暂: 左值有持久的状态, 而右值要么是字面常量, 要么是在表达式求值过程中创建的临时对象.</li>
<li>通过调用<code>std::move</code>来获得绑定到左值上的右值引用.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr1 = <span class="number">42</span>;  <span class="comment">// 正确: 字面常量是右值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = rr1; <span class="comment">// 错误: 表达式rr1是左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h2 id="14-重载运算与类型转换"><a href="#14-重载运算与类型转换" class="headerlink" title="14. 重载运算与类型转换"></a>14. 重载运算与类型转换</h2><h2 id="15-面向对象程序设计"><a href="#15-面向对象程序设计" class="headerlink" title="15. 面向对象程序设计"></a>15. <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&zhida_source=entity">面向对象程序设计</a></h2><h3 id="15-1-OOP-概述"><a href="#15-1-OOP-概述" class="headerlink" title="15.1. OOP: 概述"></a>15.1. OOP: 概述</h3><p>面向对象程序设计(object-oriented programming)的核心思想是数据抽象(封装)、继承和动态绑定(多态).</p>
<ul>
<li>通过数据抽象, 我们可以将接口与实现分离;</li>
<li>使用继承, 可以定义相似的类型并对其相似关系建模;</li>
<li>使用动态绑定, 可以在一定程度上忽略相似类型的区别, 而以统一的方式使用它们的对象.</li>
</ul>
<h3 id="15-2-定义派生类和基类"><a href="#15-2-定义派生类和基类" class="headerlink" title="15.2. 定义派生类和基类"></a>15.2. 定义派生类和基类</h3><p><strong>15.2.1. 初始化顺序</strong></p>
<ul>
<li>每个类控制它自己的成员初始化过程</li>
<li>首先初始化基类的部分, 然后按照声明的顺序依次初始化派生类的成员.</li>
</ul>
<p><strong>15.2.2. 静态多态/<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81&zhida_source=entity">动态多态</a></strong></p>
<ul>
<li>静态多态是通过重载和模板技术实现,在编译的时候确定.</li>
<li>动态多态通过虚函数和继承关系来实现,执行动态绑定, 在运行的时候确定.</li>
<li>重载: 两个函数名相同,但是参数的个数或者类型不同.</li>
<li>重写: 子类继承父类,符类中函数被声明为虚函数,子类中重新定义了这个虚函数.</li>
</ul>
<h3 id="15-3-虚函数"><a href="#15-3-虚函数" class="headerlink" title="15.3. 虚函数"></a>15.3. 虚函数</h3><ul>
<li><p>虚函数: 基类希望派生类覆盖的函数, 可以将其定义为虚函数, 这样每一个派生类可以各自定义适合自生的版本.</p>
</li>
<li><ul>
<li>当基类定义<code>virtual</code>函数的时候, 它希望派生类可以自己定义这个函数.</li>
<li>如果使用<code>virtual</code>, 程序依据引用或者指针所指向对象的类型来选择方法(method).</li>
<li>如果不使用<code>virtual</code>, 程序依据引用类型或者指针类型选择一个方法(method).</li>
</ul>
</li>
<li><p>虚函数表指针: 在有虚函数的类的对象最开始部分是一个虚函数表的指针, 这个指针指向一个虚函数表.</p>
</li>
<li><p>虚函数表中放了虚函数的地址, 实际的虚函数在代码段(.text)中.</p>
</li>
<li><p>当子类继承了父类的时候也会继承其虚函数表, 当子类重写父类中虚函数时候, 会将其继承到的虚函数表中的地址替换为重新写的函数地址.</p>
</li>
<li><p>使用了虚函数, 会增加访问内存开销, 降低效率.</p>
</li>
</ul>
<p><img src="../images/%E7%9F%A5%E8%AF%86%E7%82%B9-C++/v2-ad2cca1f214d61933a1afcaaae7f36be_1440w.webp" alt="img"></p>
<p><strong>15.3.1. 虚析构函数</strong></p>
<p>Q: 析构函数为什么是虚函数?</p>
<p>A: 将可能会被继承的基类的析构函数设置为虚函数, 可以保证当我们<code>new</code>一个派生类, 然后使用基类指针指向该派生类对象, 基类指针时可以释放掉派生类的空间, 防止内存泄漏.</p>
<p>Q: 为什么 C++ 默认析构函数不是虚函数?</p>
<p>A: C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针, 占用额外的内存; 所以只有当一个类会被用作基类时才将其设置为虚函数.</p>
<h3 id="15-4-抽象基类"><a href="#15-4-抽象基类" class="headerlink" title="15.4. 抽象基类"></a>15.4. 抽象基类</h3><ul>
<li><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0&zhida_source=entity">纯虚函数</a>是一种特殊的虚函数, 在基类中不能对虚函数给出有意义的实现, 而把它声明为纯虚函数, 它的实现留给该基类的派生类去做. 书写<code>=0</code>就可以将一个虚函数说明为纯虚函数.</li>
<li>含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类(abstract base class).</li>
</ul>
<p>虚函数 VS 纯虚函数</p>
<ul>
<li>类里如果声明了虚函数, 这个函数是实现的, 哪怕是空实现, 它的作用就是为了能让这个函数在它的子类里面可以被覆盖(override), 这样的话, 编译器就可以使用后期绑定来达到多态了. 纯虚函数只是一个接口, 是个函数的声明而已, 它要留到子类里去实现.</li>
<li>虚函数在子类里面可以不重写; 但纯虚函数必须在子类实现才可以实例化子类.</li>
<li>虚函数的类用于 “实作继承”, 继承接口的同时也继承了父类的实现. 纯虚函数关注的是接口的统一性, 实现由子类完成.</li>
<li>带纯虚函数的类叫抽象类, 这种类不能直接生成对象, 而只有被继承, 并重写其虚函数后, 才能使用. 抽象类被继承后, 子类可以继续是抽象类, 也可以是普通类.</li>
</ul>
<h3 id="15-5-访问控制与继承"><a href="#15-5-访问控制与继承" class="headerlink" title="15.5. 访问控制与继承"></a>15.5. 访问控制与继承</h3><ul>
<li><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF&zhida_source=entity">公有继承</a>保持原始状态(没有特殊要求一般用公有继承)</li>
<li>私有继承基类的所有成员都作为派生类的私有成员</li>
<li>保护继承基类的<code>public</code>作为派生类的保护成员, 其他不变.</li>
</ul>
<h2 id="16-模板与泛型编程"><a href="#16-模板与泛型编程" class="headerlink" title="16. 模板与泛型编程"></a>16. 模板与<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B&zhida_source=entity">泛型编程</a></h2><h2 id="17-标准库特殊实施"><a href="#17-标准库特殊实施" class="headerlink" title="17. 标准库特殊实施"></a>17. 标准库特殊实施</h2><h2 id="18-用于大型程序的工具"><a href="#18-用于大型程序的工具" class="headerlink" title="18. 用于大型程序的工具"></a>18. 用于大型程序的工具</h2><h3 id="18-1-多重继承与虚继承"><a href="#18-1-多重继承与虚继承" class="headerlink" title="18.1. 多重继承与虚继承"></a>18.1. 多重继承与<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E8%99%9A%E7%BB%A7%E6%89%BF&zhida_source=entity">虚继承</a></h3><ul>
<li>虚继承是解决 C++ 多重继承问题的一种手段, 从不同途径继承来的同一基类, 会在子类中存在多份拷贝, 即浪费存储空间, 又存在<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E4%BA%8C%E4%B9%89%E6%80%A7&zhida_source=entity">二义性</a>的问题.</li>
<li>底层实现原理与编译器相关, 一般通过虚基类指针和虚基类表实现, 每个虚继承的子类都有一个虚基类指针(占用一个指针的存储空间, 4 字节)和虚基类表(不占用类对象的存储空间)(需要强调的是, 虚基类依旧会在子类里面存在拷贝, 只是仅仅最多存在一份而已, 并不是不在子类里面了); 当虚继承的子类被当做父类继承时, 虚基类指针也会被继承.</li>
<li>实际上, vbptr 指的是虚基类表指针(virtual base table pointer), 该指针指向了一个虚基类表(virtual table), 虚表中记录了虚基类与本类的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80&zhida_source=entity">偏移地址</a>; 通过偏移地址, 这样就找到了虚基类成员, 而虚继承也不用像普通<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%A4%9A%E7%BB%A7%E6%89%BF&zhida_source=entity">多继承</a>那样维持着公共基类(虚基类)的两份同样的拷贝, 节省了存储空间.</li>
</ul>
<h2 id="19-特殊工具和技术"><a href="#19-特殊工具和技术" class="headerlink" title="19. 特殊工具和技术"></a>19. 特殊工具和技术</h2><h3 id="19-1-控制内存分配"><a href="#19-1-控制内存分配" class="headerlink" title="19.1. 控制内存分配"></a>19.1. 控制内存分配</h3><p><strong>19.1.1. <code>new</code> &amp; <code>delete</code></strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *sp = new string(&quot;a value); // 分配并初始化一个string对象</span><br><span class="line">string *arr = new string[10];      // 分配10个默认初始化的string对象</span><br></pre></td></tr></table></figure>

<p>当我们使用一条<code>new</code>表达式时, 实际执行了三步操作:</p>
<ol>
<li><code>new</code>表达式调用一个名为<code>operate new</code>(或者<code>operate new[]</code>)的标准库函数. 该函数(从自由存储区上)分配一块足够大的, 原始的, 未命名的内存空间(无需指定内存块的大小)以便存储特定类型的对象(或对象的数组).</li>
<li>编译器运行相应的构造函数以构造这些对象, 并为其传入初值.</li>
<li>对象被分配了空间并构造完成, 返回一个指向该对象的指针.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> sp;  <span class="comment">// 销毁*sp, 然后释放sp指向的内存空间</span></span><br><span class="line"><span class="keyword">delete</span> [] arr; <span class="comment">// 销毁数组中的元素, 然后释放对应的内存空间</span></span><br></pre></td></tr></table></figure>

<p>当我们使用一条<code>delete</code>表达式删除一个动态分配的对象时, 实际执行了两步操作:</p>
<ol>
<li>对<code>sp</code>所指的对象或者<code>arr</code>所指的数组中的元素执行对应的析构函数.</li>
<li>编译器调用名为<code>operate delete</code>(或者<code>operate delete[]</code>)的标准库函数释放内存空间.</li>
</ol>
<p><strong>19.1.2. <code>malloc</code>&amp;<code>free</code></strong></p>
<ul>
<li><code>malloc</code>需要显式的指出内存大小: 函数接受一个表示待分配字节数的<code>size_t</code>.</li>
<li>返回指向分配空间的指针(<code>void*</code>)或者返回 0 以表示分配失败. (从堆上<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98&zhida_source=entity">动态分配内存</a>)</li>
<li><code>free</code>函数接受一个<code>void*</code>, 它是<code>malloc</code>返回的指针的副本, <code>free</code>将相关内存返回给系统. 调用<code>free(0)</code>没有任何意义.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// operate new的一种简单实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> *operater <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">void</span> *men = <span class="built_in">malloc</span>(size))</span><br><span class="line">        <span class="keyword">return</span> mem;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// opearte delete的一种简单实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *mem)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="built_in">free</span>(mem); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-2-固有的不可移植特性"><a href="#19-2-固有的不可移植特性" class="headerlink" title="19.2. 固有的不可移植特性"></a>19.2. 固有的不可移植特性</h2><p><strong>19.2.1. <code>volatile</code></strong></p>
<ul>
<li>当对象的值可能在程序控制或检测之外(操作系统、硬件、其它线程等)被改变时, 应该将该对象声名为<code>volatile</code>. 关键字<code>volatile</code>告诉编译器不应对这样的对象进行优化.</li>
<li><code>volatile</code>关键字声明的变量, 每次访问时都必须从内存中取出值(没有被<code>volatile</code>修饰的变量, 可能由于编译器的优化, 从 CPU 寄存器中取值).</li>
</ul>
<p><strong>19.2.2. <code>extern</code></strong></p>
<ul>
<li>在多个文件之间共享对象.</li>
<li><code>extern &quot;C&quot;</code>的作用是让 C++ 编译器将<code>extern &quot;C&quot;</code>声明的代码当作 C 语言代码处理, 可以避免 C++ 因符号修饰导致代码不能和 C 语言库中的符号进行链接的问题.</li>
</ul>
<h2 id="20-链接装载与库"><a href="#20-链接装载与库" class="headerlink" title="20. 链接装载与库"></a>20. 链接装载与库</h2><blockquote>
<p>本小节内容大部分摘录自《<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB&zhida_source=entity">程序员的自我修养</a> - 链接装载与库》</p>
</blockquote>
<h3 id="20-1-h-和-cpp-文件的区别"><a href="#20-1-h-和-cpp-文件的区别" class="headerlink" title="20.1. .h 和 .cpp 文件的区别"></a>20.1. .h 和 .cpp 文件的区别</h3><ul>
<li>.h文件里面放申明, .cpp文件里面放定义.</li>
<li>.cpp文件会被编译成实际的二进制代码, 而.h文件是在被 include 中之后复制粘贴到 .cpp 文件里.</li>
</ul>
<h3 id="20-2-编译和链接"><a href="#20-2-编译和链接" class="headerlink" title="20.2. 编译和链接"></a>20.2. 编译和链接</h3><ol>
<li><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E9%A2%84%E7%BC%96%E8%AF%91&zhida_source=entity">预编译</a>(预处理): 预编译过程主要处理那些源代码文件中的以”#”开始的预编译指令. 比如”<code>#include</code>“、”<code>#define</code>“等. 生成<code>.i</code>或者<code>.ii</code>文件.</li>
<li>编译: 把预处理完的文件进行一系列的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90&zhida_source=entity">词法分析</a>、语法分析、语义分析及优化后生产相应的汇编代码文件(<code>.s</code>文件).</li>
<li>汇编: 将汇编代码转变成机器可以执行的指令(机器码), 生成<code>.o</code>文件.</li>
<li>链接: 链接器进行地址和空间分配、符号决议、重定位等步骤, 生成 <code>.out</code>文件.</li>
</ol>
<h3 id="20-3-程序的内存布局"><a href="#20-3-程序的内存布局" class="headerlink" title="20.3. 程序的内存布局"></a>20.3. 程序的内存布局</h3><p>一般来讲, 应用程序使用的内存空间里有如下”默认”区域.</p>
<ul>
<li><p>栈: 栈用于维护函数调用的上下文. 由操作系统自动分配释放, 一般包含以下几个方面:</p>
</li>
<li><ul>
<li>函数的返回地址和参数</li>
<li>临时变量: 包括函数的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E9%9D%9E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F&zhida_source=entity">非静态局部变量</a>以及编译器自动生成的其他临时变量</li>
<li>保存上下文: 包括函数调用前后需要保持不变的寄存器</li>
</ul>
</li>
<li><p>堆: 堆是用来容纳应用程序动态分配的内存区域. 由程序员分配释放 ,当程序使用<code>malloc</code>或者<code>new</code>分配内存时, 得到的内存来自堆里.</p>
</li>
<li><p>可执行文件映像: 存储着可执行文件在内存里的映像, 由装载器在装载时将可执行文件的内存读取或映射到这里.</p>
</li>
<li><ul>
<li><code>.data</code>: 静态区, 存放全局变量和局部静态变量.</li>
<li><code>.bss</code>: 存放未初始化的全局变量和局部静态变量.</li>
<li><code>.text</code>: 代码区, 存放 C 语言编译后的机器代码, 不可在运行期间修改.</li>
</ul>
</li>
<li><p>保留区: 保留区并不是一个单一的内存区域, 而是对内存中受到保护而禁止访问的内存区域的总称. 如通常 C 语言将无效指针赋值为 0(NULL), 因此 0 地址正常情况下不可能有有效的访问数据.</p>
</li>
</ul>
<p><img src="../images/%E7%9F%A5%E8%AF%86%E7%82%B9-C++/v2-d0dca114d14bb8f09d36e63050735757_1440w.webp" alt="img"></p>
<p>图 20.1 Linux 进程地址空间布局</p>
<p><strong>20.3.1. <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E6%AE%B5%E9%94%99%E8%AF%AF&zhida_source=entity">段错误</a></strong></p>
<p>Q: 程序出现”段错误(segment fault)”或者”非法操作, 该内存地址不能 read/wirte”的错误信息, 是什么原因?</p>
<p>A: 这是典型的非法指针解引用造成的错误. 当指针指向一个不允许读或写的内存地址, 而程序却试图利用指针来读或写该地址的时候, 就会出现这个错误. 可能的段错误发生的时机如下:</p>
<ul>
<li>指针没有初始化或者初始化为<code>nullptr</code>, 之后没有给它一个合理的值就开始使用指针.</li>
<li>使用<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E9%87%8E%E6%8C%87%E9%92%88&zhida_source=entity">野指针</a>(指向一个已删除的对象或者未申请访问受限内存区域的指针).</li>
<li>指向常量的指针试图修改相关内容.</li>
</ul>
<h3 id="20-4-编译型语言-VS-解释型语言"><a href="#20-4-编译型语言-VS-解释型语言" class="headerlink" title="20.4. 编译型语言 VS 解释型语言"></a>20.4. 编译型语言 VS <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80&zhida_source=entity">解释型语言</a></h3><ul>
<li>有的编程语言要求必须提前将所有源代码一次性转换成二进制指令, 也就是生成一个可执行程序(Windows 下的 .exe), 比如 C 语言、C++、Golang、Pascal（<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=Delphi&zhida_source=entity">Delphi</a>）、汇编等, 这种编程语言称为编译型语言, 使用的转换工具称为编译器.</li>
<li>有的编程语言可以一边执行一边转换, 需要哪些源代码就转换哪些源代码, 不会生成可执行程序, 比如 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=Python&zhida_source=entity">Python</a>、JavaScript、PHP、<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238218812&content_type=Article&match_order=1&q=MATLAB&zhida_source=entity">MATLAB</a> 等, 这种编程语言称为解释型语言, 使用的转换工具称为解释器.</li>
</ul>
<h1 id="其他常见问题"><a href="#其他常见问题" class="headerlink" title="其他常见问题"></a>其他常见问题</h1><p><strong><code>final</code>和<code>override</code>的作用？<code>final</code>为什么能提高代码执行效率？</strong></p>
<blockquote>
<p><code>override</code>：保证在<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E6%B4%BE%E7%94%9F%E7%B1%BB&zhida_source=entity">派生类</a>中声明的重载函数，与基类的虚函数有相同的签名，作用就是用于编译期代码检查。<br><code>final</code>：阻止类的进一步派生和虚函数的进一步重写，同时也是一种名为去虚拟化的优化技巧，相当于把运行期多态转换为了<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81&zhida_source=entity">编译期多态</a>，提高了执行效率。</p>
</blockquote>
<p><strong>(2)<code>static</code>的3种作用？</strong></p>
<blockquote>
<p>修饰局部变量，这意味着该变量只被初始化一次，并保留其值直到程序结束。<br>修饰全局变量，这意味着该变量具有文件作用域。<br>修饰成员变量，这意味着变量不会绑定到对象上。</p>
</blockquote>
<p><strong>(3)<code>thread_local</code>作用和原理？</strong></p>
<blockquote>
<p><code>thread_local</code>用来定义一个<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F&zhida_source=entity">线程本地变量</a>，每个线程都拥有自己的<code>thread_local</code>对象副本，这些副本放在各个线程自己的TLS空间。<code>thread_local</code>描述的对象在thread开始时分配，而在thread结束时释放。</p>
</blockquote>
<p><strong>(4)一个变量可以既是<code>const</code>又是<code>volatile</code>吗？</strong></p>
<blockquote>
<p>可以。<code>const</code>的作用是告诉编译器，编译期间不允许对变量进行修改，编译器在编译期间往往会对<code>const</code>变量执行一种名为字符替换的优化。<code>volatile</code>的作用是告诉编译器，第一，编译期间不要对该变量进行优化；第二，运行期间，每次必须从内存中加载变量的值。<code>const volatile</code>表示一个变量在程序编译期不能被修改且不能被优化；在程序运行期，每次必须从内存中加载变量的值。</p>
</blockquote>
<p><strong>(5)<code>NULL</code>和<code>nullptr</code>区别？为什么要引入<code>nullptr</code>？</strong></p>
<blockquote>
<p>主流编译器中，<code>NULL</code> 实际上是一个整数常量，被定义为 <code>0</code>，在 C++11 之前，当我们想要将一个<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E6%8C%87%E9%92%88%E5%88%9D%E5%A7%8B%E5%8C%96&zhida_source=entity">指针初始化</a>为空时，我们通常使用 <code>NULL</code>；<code>nullptr</code> 是 C++11 中引入的新的关键字，专门用于表示空指针，它不是整数类型，而是特殊的指针类型<code>nullptr_t</code>。之所以引入<code>nullptr</code>，第一，<code>NULL</code>是整数类型，用户调用foo(NULL)的时候，不能区分调用的是<code>foo(int)</code>还是<code>foo(int*)</code>函数；第二，主流编译器中<code>NULL</code>值为<code>0</code>，通过<code>0</code>表示一个无效地址，但是有的架构下，<code>0</code>地址有特定用途，而<code>nullptr</code>指向的永远是一个无效地址。</p>
</blockquote>
<p><strong>(6)为什么<code>noexcept</code>能提高性能？</strong></p>
<blockquote>
<p>使用 <code>noexcept </code>可以让编译器对代码进行优化，从而提高代码的性能。具体来说，为实现异常捕获的功能，c++引入了“栈回退”机制，编译器在编译函数的时候，会为函数生成额外的叫做“栈回退”的代码，使用<code>noexcept</code> 可以避免生成额外的代码来处理异常情况，这样可以减少代码量和执行时间。关闭异常捕获是比较危险的行为，一般只建议用在构造函数。</p>
</blockquote>
<p><strong>(7)<code>delete[]</code>是怎样知道数组长度的？</strong></p>
<blockquote>
<p>没有标准实现，一种常见的实现方法是，申请内存时，会在返回的指针前面存放这段内存的大小，调用<code>delete[]</code>的时候，就可以知道数组长度了。</p>
</blockquote>
<p><strong>(8)<code>new</code>，<code>placement new</code>，<code>operator new</code>的区别？怎么在把对象new在栈上？</strong></p>
<blockquote>
<p><code>operator new</code>作用是分配一块内存，<code>placement new</code>作用是在已分配内存地址处，创建一个对象，<code>new</code>的作用则等于<code>operator new</code> + <code>placement new</code>。先在栈上声明一个数组，然后通过<code>placement new</code> 在这段地址处创建对象，这就实现了在栈上new一个对象。</p>
</blockquote>
<p><strong>(9)<code>__cdecl</code>和<code>__stdcall</code>区别？</strong></p>
<blockquote>
<p>都是 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=Microsoft+Visual+C++&zhida_source=entity">Microsoft Visual C++</a> 中用于声明<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A&zhida_source=entity">函数调用约定</a>的关键字。<code>__cdecl</code> 是 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=C/C++&zhida_source=entity">C/C++</a> 默认的调用约定，在 <code>__cdecl</code> 调用约定下，参数从右往左入栈，由调用方负责清理<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E5%A0%86%E6%A0%88&zhida_source=entity">堆栈</a>；在<code>__stdcall</code> 调用约定下，函数参数从右向左压入堆栈中，函数堆栈的清除工作由被调用方负责。这些关键字主要用于跨语言调用，以确保参数传递和堆栈清理的一致性。</p>
</blockquote>
<p><strong>(10)重载类的delete运算符，delete的时候会发生什么？</strong></p>
<blockquote>
<p><code>new</code>的默认行为是先分配一段内存，然后调用对象的构造函数，把对象创建在这段内存上；<code>delete</code>的默认行为是先调用析构函数，然后释放内存。重载全局<code>new</code>和<code>delete</code>运算符号，会修改所有的<code>new</code>和<code>delete</code>内存行为，重载类的<code>new</code>和<code>delete</code>运算符，会修改针对这个类的<code>new</code>和<code>delete</code>内存行为。</p>
</blockquote>
<p><strong>(11)函数调用压栈流程？</strong></p>
<blockquote>
<p>不同系统下压栈的具体操作不同，但大致都有这么个过程：函数调用的时候，把被调用函数参数压栈，把预留的返回值存放位置压栈，把当前函数上下文，比如栈地址相关的寄存器和指令地址相关的寄存器内容压栈，函数返回的时候，弹出函数参数和返回值，弹出函数上下文内容到寄存器，恢复现场。</p>
</blockquote>
<p><strong>(12)声明和定义的作用，从编译角度说明？</strong></p>
<blockquote>
<p>声明的作用主要两点，第一，提供链接时需要的符号信息，这些信息存储在目标文件的重定位表和<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E7%AC%A6%E5%8F%B7%E8%A1%A8&zhida_source=entity">符号表</a>当中；第二，提供类型大小信息，c++采取的是单文件编译策略，当不知道某个符号对应类型的定义的时候，需要在链接前预留出合适大小的内存空间，供链接时填充。</p>
</blockquote>
<p><strong>(13)现代大部分编程语言都没有头文件，c++为什么有头文件？头文件和模块的优劣比较？#include和前置声明的区别？</strong></p>
<blockquote>
<p>c++和采取模块机制的编程语言的一个重大区别在于，c++把函数和变量签名这部分信息保存在头文件内，而采取模块机制的编程语言把这部分信息保存在库内。头文件和模块相比，会拷贝很多无用的声明信息到当前文件内，从而导致编译非常慢，另一个缺点就是头文件机制很容易引发符号重定义错误。c++之所以采用头文件机制是因为，早期计算机的内存资源非常珍贵，如果把函数和变量签名信息都保存到二进制库中，会浪费更多的内存资源。<br><code>#include</code>和前置声明本质上都是声明，区别在于<code>#include</code>在预处理期间做了一次拷贝声明的操作，前置声明的优势在于可以按需导入函数，而且可以解决<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96&zhida_source=entity">循环依赖</a>问题。</p>
</blockquote>
<p><strong>(14)C++11为什么引入枚举类？</strong></p>
<blockquote>
<p>传统的 C++ <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B&zhida_source=entity">枚举类型</a>会将枚举值暴露在<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4&zhida_source=entity">命名空间</a>中，容易造成命名冲突，而枚举类则通过引入了<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%99%90%E5%AE%9A%E7%AC%A6&zhida_source=entity">作用域限定符</a>来解决这个问题。其次，传统的 C++ 枚举类型是基于整数的，可以进行隐式的类型转换和比较操作，这可能会导致一些意想不到的错误，而枚举类则可以避免这个问题，因为它们只能进行显式的类型转换和比较操作。</p>
</blockquote>
<p><strong>(15)程序是从<code>main</code> 函数开始执行的吗？</strong></p>
<blockquote>
<p>不是，程序在执行前，会经历一个从磁盘加载程序到内存的过程，这个过程会执行全局变量的初始化。</p>
</blockquote>
<p><strong>(16)虚函数怎么实现的？真的更慢吗？</strong></p>
<blockquote>
<p>虚函数是通过<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8&zhida_source=entity">虚函数表</a>实现的，每个类都有自己的虚表，对象的首地址处存放有指向虚表的指针。当具体调用哪个虚函数可以在编译期间确定的时候，虚函数不一定更慢。</p>
</blockquote>
<p><strong>(17)构造函数、析构函数、重载运算符函数可以是虚函数吗？类成员函数模板可以是虚函数吗？</strong></p>
<blockquote>
<p>析构函数和重载运算符函数都可以是虚函数，而构造函数不能是虚函数，首先C++编译器层面不允许这种操作，第二构造函数不需要动态多态，C++引入虚函数的目的就是为了解决编译期间无法确定调用对象的问题，而对于构造函数这类<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0&zhida_source=entity">特殊函数</a>，编译期间就已经明确知道需要创建的对象类型。类成员函数模板不能是虚函数，因为C++在链接前是不知道成员函数模板被实例化多少次的，这就会导致编译器无法在编译期间确定虚表的大小。</p>
</blockquote>
<p><strong>(18)成员函数指针和普通函数指针区别？</strong></p>
<blockquote>
<p>普通函数指针属于指针类型，成员函数指针不是指针类型。通常来说，函数指针的长度等于<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E6%9C%BA%E5%99%A8%E5%AD%97%E9%95%BF&zhida_source=entity">机器字长</a>，而成员函数指针长度比函数指针更长，其内部存放了对象地址和成员函数地址信息。在没有给出对象地址的情况下，调用成员函数指针会报错。</p>
</blockquote>
<p><strong>(19)各种变量存放在虚拟内存的哪个分区？</strong></p>
<blockquote>
<p>直接声明的变量、函数实参存储在栈区；new创建的对象，较小的对象存放在堆 区，较大的对象存放在共享内存区；常量和<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F&zhida_source=entity">静态变量</a>存放在静态存储区中的非代码区；所有函数存放在静态存储区中的代码区；字符常量也存放在代码区。</p>
</blockquote>
<p><strong>(20)对象的内存模型？发生继承时候的对象内存模型？</strong></p>
<blockquote>
<p>成员函数存放在代码区；静态成员变量存放在静态存储区；普通成员变量存放在对象内，且按照声明顺序依次存放；如果类声明了虚函数，那么对象的首地址处往往会存放一个指向虚表的指针，另外访问权限关键字可能会影响对象的内存布局，至于怎么影响，标准没有规定，不同编译器的实现可能不同。发生继承的时候，基类对象怎样存放，标准也没有规定，一般是按照继承顺序依次存放在内存当中，每个对象都可以有自己的虚表。</p>
</blockquote>
<p><strong>(21)什么是标准布局类型和<code>trivial</code>类型？有什么用？</strong></p>
<blockquote>
<p>引入标准布局类型是为了向C语言兼容，使得用户能够通过对象第一个成员的指针类型指向对象；引入<code>trivial</code>类型是为了提高对象初始化效率，<code>memcpy</code>比构造函数初始化效率效率更高。不考虑继承，一个类没有虚函数、所有非静态变量的访问权限相同，则是标准布局类型；不考虑继承，一个类没有自定义构造、自定义析构函数，没有虚函数，则是<code>trivial</code>类型。</p>
</blockquote>
<p><strong>(22)什么是类型擦除？实现方式？</strong></p>
<blockquote>
<p>类型擦除是一种，使得不同类型变量能够得到统一处理的技术。实现方式上可分为静态类型擦除了动态类型擦除，静态类型擦除通过模板或者宏实现，动态类型擦除可通过继承虚函数或者void类型实现。</p>
</blockquote>
<p><strong>(23)什么是多态？实现方式？</strong></p>
<blockquote>
<p>多态指的是一种相同的形式表现出不同行为的概念，分为静态多态和动态多态。代码层面，静态多态通过重载（overload）实现，动态多态通过覆盖（override）实现；原理层面，静态多态通过name mangling实现，动态多态通过虚表实现。</p>
</blockquote>
<p><strong>(24)<code>inline</code>的作用和原理？</strong></p>
<blockquote>
<p>c++17以前，<code>inline</code>关键字主要有两个作用：第一，作为内联优化建议，告诉编译器在调用处展开函数，只不过是否展开函数还是由编译器决定；第二，解决符号重定义问题，不同文件内定义了同签名的函数，若被inline关键字修饰，则不会引发符号重定义错误。c++17开始，inline只保留第二个作用，若用户希望函数内联展开，则可以使用<code>__attribute((always_inline))__ </code>关键字，它是 GCC 和 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=Clang&zhida_source=entity">Clang</a> 中的一个扩展，用于强制内联函数。。<br>原理上，第一，内联展开相比于普通函数调用，少了函数上下文压栈的过程，因此效率更高，缺点就是容易引起代码膨胀。第二，被<code>inline</code>关键字修饰的函数名，编译期间会被标记为weak符号，链接目标文件的时候，多个同签名weak符号不会引发编译器报错，运行期间，会选取其中一个函数进行调用。</p>
</blockquote>
<p><strong>(25)<code>inline</code>用作内联展开这层含义的时候，构造函数、析构函数、虚函数可以被<code>inline</code>修饰吗？可以获取<code>inline</code>函数的指针吗？<code>static inline</code>和<code>extern inline</code>含义？</strong></p>
<blockquote>
<p>任何函数都可以被<code>inline</code>修饰，包括构造函数、析构函数、虚函数。这里提一下为什么虚函数可以内联，<code>inline</code>函数涉及到的是编译期解析，虚函数地址大多数情况下在运行期解析，但是某些情况下，具体调用哪个虚函数可以在编译期间确定，这个时候虚函数就能内联展开了。<br><code>inline</code>只作为内联建议，是否展开由编译器决定，因此是可以获取<code>inline</code>函数指针的。<br><code>static inline</code>指的是具有文件作用域的<code>inline</code>函数；<code>extern inline</code>作用比较特殊，外部单元把它当作普通函数进行调用，同单元内把它当作<code>inline</code>函数调用。</p>
</blockquote>
<p><strong>(26)<code>malloc</code>和<code>new</code>区别？<code>malloc</code>实现原理？<code>free</code>后，内存被释放了吗？</strong></p>
<blockquote>
<p><code>malloc</code>只分配一段内存，<code>new</code>会先分配一段内存，然后在这段内存上创建对象。<code>malloc</code>实现上，先从用户态切换到内核态，分配一段空闲物理内存，接着在虚拟内存堆空间或者共享内存空间分配一段虚拟内存，然后填充页表，把虚拟内存映射到物理内存，最后返回用户态。<code>free</code>后，内存没有被立即释放，而是保留在内存当中，作为<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E5%86%85%E5%AD%98%E6%B1%A0&zhida_source=entity">内存池</a>的一部分供下次使用。</p>
</blockquote>
<p><strong>(27)谈谈<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=lambda%E5%87%BD%E6%95%B0&zhida_source=entity">lambda函数</a>？</strong></p>
<blockquote>
<p>lambda函数可以看作是函数对象的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E8%AF%AD%E6%B3%95%E7%B3%96&zhida_source=entity">语法糖</a>，可以随地定义和调用。可通过lambda和智能指针实现闭包，c++17以前，lambda不支持<code>*this</code>捕获，c++17开始支持<code>*this</code>捕获，即<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0&zhida_source=entity">非静态成员函数</a>内部定义的lambda函数不需要通过显式指定this，就可以访问对象成员。</p>
</blockquote>
<p><strong>(28)<code>union</code>和<code>struct</code>和<code>class</code>的区别？</strong></p>
<blockquote>
<p><code>struct</code>和<code>class</code>都可以用来定义类，<code>struct</code>成员默认<code>public</code>，<code>class</code>成员默认<code>private</code>，只不过从语义上来说，建议用<code>struct</code>定义数据块，<code>class</code>定义类。<code>struct</code> 每个成员变量都有自己的内存地址；<code>union</code> 内存占用大小为其成员中需要空间最大者，每个成员变量都占用相同的内存单元。</p>
</blockquote>
<p><strong>(29)什么是零三五原则？</strong></p>
<blockquote>
<p>零之法则：对于不需要通过析构函数回收资源的类，只定义普通构造函数。<br>三之法则：如果某个类需要用户定义析构函数回收资源，那么这个类除了要定义普通构造函数外，也一定要定义复制构造函数、赋值运算函数。<br>五之法则：因为用户定义的析构函数、复制构造函数或复制赋值运算符的存在会阻止<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&zhida_source=entity">移动构造函数</a>和<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6&zhida_source=entity">移动赋值运算符</a>的隐式定义，所以任何想要移动语义的类必须声明全部五个特殊成员函数</p>
</blockquote>
<p><strong>(30)C++可调用类型有哪些？</strong></p>
<blockquote>
<p>函数指针、函数对象、<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F&zhida_source=entity">lambda表达式</a>、成员函数指针。</p>
</blockquote>
<p><strong>(31)为什么把析构函数定义为虚函数？</strong></p>
<blockquote>
<p>解决<code>delete</code> 指向子类对象的基类指针的时候，只析构基类、不析构子类的问题。</p>
</blockquote>
<p><strong>(32)构造函数和析构函数的调用顺序？</strong></p>
<blockquote>
<p>创建对象过程，先调用基类的构造函数，然后依次调用类非静态成员的构造函数，最后调用自己的构造函数；销毁对象过程，先调用自己的析构函数，然后依次调用非静态成员的析构函数，最后调用基类的析构函数。</p>
</blockquote>
<p><strong>(33)指针和引用的区别？</strong></p>
<blockquote>
<p>引用和指针在<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E6%B1%87%E7%BC%96&zhida_source=entity">汇编</a>层面都是内存地址，引用可以看作是<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F&zhida_source=entity">指针常量</a>，只能在声明的时候初始化，相比于指针，引用的优势在于编译器帮我们检查地址是否初始化。</p>
</blockquote>
<p><strong>(34)符号重定义的解决方法？</strong></p>
<blockquote>
<p>通过<code>extern</code>，<code>static</code>，<code>inline</code>，<code>const</code>关键字都可以解决符号重定义问题，也可以通过命名空间、前置声明、<code>#ifndef</code>和<code>#pragma once</code>宏解决这个问题。</p>
</blockquote>
<p><strong>(35)四种指针类型转换的区别？</strong></p>
<blockquote>
<p><code>reinterpret_cast</code>用于任意指针（引用）类型之间的转换，不进行类型检查。<br><code>static_cast</code>用于基类和子类指针（引用）之间的转换，编译期进行类型检查。<br><code>dynamic_cast</code>用于基类和子类指针（引用）之间的转换，运行期进行类型检查。<br><code>const_cast</code>用于指针（引用）类型，用于删除限定符，不进行类型检查。</p>
</blockquote>
<p><strong>(36)知道什么是RVO吗？</strong></p>
<blockquote>
<p>RVO是一种返回值优化手段，它通过避免创建临时对象来提高代码性能。当一个函数返回一个非引用类型的变量时，编译器会尝试将该对象直接构造在调用者的栈帧空间中，而不是为该对象分配新的内存并在函数返回后再将其拷贝到调用者的栈帧空间中。</p>
</blockquote>
<p><strong>(37)RTTI的实现原理？</strong></p>
<blockquote>
<p>RTTI指的是运行时类型识别，通过虚表实现，指向类型信息的指针存放在虚表上。</p>
</blockquote>
<p><strong>(38)extern C的作用？</strong></p>
<blockquote>
<p><code>extern &quot;C&quot;</code> 是 C++ 提供的一个关键字，用于指示编译器将某个函数或变量的名称按照 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=C+%E8%AF%AD%E8%A8%80&zhida_source=entity">C 语言</a>的方式进行处理，以便与C语言进行交互。其原理上就是关闭编译器的name mangling。</p>
</blockquote>
<p><strong>(39)可以在运行时访问private成员吗？</strong></p>
<blockquote>
<p>可以，访问权限关键字只在编译期有效，运行期是没有访问权限关键字这些概念的，可以在运行时访问对象内的任何成员。</p>
</blockquote>
<p><strong>(40)C++的编译流程？</strong></p>
<blockquote>
<p>先预处理，然后编译成目标文件，接着把目标文件链接成库文件或者可执行文件。</p>
</blockquote>
<p><strong>(41)动态库和静态库的区别？知道动态库延迟加载优化吗？</strong></p>
<blockquote>
<p>链接动态库和静态库的时候，静态库会被复制到可执行程序当中，而动态库不会。相比动态库，静态库的执行效率更高，但占用磁盘空间更多，不方便更新。动态库的延迟加载指的是，在运行时按需加载<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93&zhida_source=entity">动态链接库</a>中的函数和数据，而不是在启动的时候加载库函数和数据，从而降低启动时间，在<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=linux%E7%B3%BB%E7%BB%9F&zhida_source=entity">linux系统</a>下，延迟加载是通过PLT表和GOT表配合实现的。</p>
</blockquote>
<p><strong>(42)智能指针是什么？几种智能指针的区别？</strong></p>
<blockquote>
<p>智能指针是RAII思想的一种应用，<code>shared_ptr</code>是最常用的智能指针，但是，第一，效率低，可以通过在特定场合使用<code>unique_ptr</code>弥补这点；第二，有<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8&zhida_source=entity">循环引用</a>的问题，故引入<code>weak_ptr</code>；第三，不能直接封装this并返回，否则会引起<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0&zhida_source=entity">引用计数</a>错误，故引入<code>enable_shared_from_this</code>。</p>
</blockquote>
<p><strong>(43)四种智能指针的简单实现？</strong></p>
<blockquote>
<p>不考虑删除器的实现，<code>unique_ptr</code>内部封装一个指针，在构造函数内把地址传给指针，析构函数内销毁指针指向的对象；<code>shared_ptr</code>内部封装一个指针，和一个存放在堆空间的引用计数，重新实现构造、<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0&zhida_source=entity">拷贝构造</a>、赋值构造、析构函数，每次调用构造函数、赋值构造函数、拷贝构造函数的时候，通过原子操作，对引用计数加1，每次调用析构函数，通过原子操作对引用计数减1，计数为0则销毁对象；<code>weak_ptr</code>实现和<code>shared_ptr</code>类似，不同在于它不影响引用计数；<code>enable_shared_from_this</code>通过CRTP实现。</p>
</blockquote>
<p><strong>(44)什么是左值和右值？它们是C++11才有的吗？<code>string literal</code>是左值还是右值？<code>i++</code>和<code>++i</code>是左值还是右值</strong></p>
<blockquote>
<p>左值是可以取地址的值，右值是不可取地址的值，右值之所以不能取地址，往往是因为这些值可能在寄存器上、可能是指令的一部分、可能是栈上的匿名变量。左右值是C语言出现开始，一直都有的概念，只是没有给他们明确下定义。<code>string literal</code>是左值，<code>++i</code>是返回值是<code>i</code>本身，是左值，<code>i++</code>会返回一个临时变量，是右值。</p>
</blockquote>
<p><strong>(45)什么是左右值引用？和左右值有关系吗？右值引用适合什么场景下用？</strong></p>
<blockquote>
<p>左值引用和右值引用在汇编层面都是地址，右值引用的出现是伴随着移动构造函数出现的，之所以引入右值引用类型的语法，是为了区分拷贝构造函数和移动构造函数，更准确地来说是为了区分深拷贝和浅拷贝。只有右值才可以赋值给右值引用，但是右值和右值引用没有严格意义上的关系，把右值赋值给右值引用往往是不合理的，反而会降低运行效率，不要把字面值赋值给右边值引用，不要以右值引用的方式返回函数返回值。右值引用仅仅适用于把将亡值传递给函数参数这类场景。</p>
</blockquote>
<p><strong>(46)基本类型的长度？</strong></p>
<blockquote>
<p>这些长度可能会因编译器、操作系统和<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&zhida_source=entity">计算机体系结构</a>的不同而有所变化。<code>char</code>长度是1字节；<code>short</code>长度至少2字节，大多情况下2字节；<code>int</code>长度至少2字节，大多数情况下4字节；<code>long int</code>长度大于等于<code>int</code>长度；<code>float</code>长度4字节；<code>double</code>长度8字节。所以为了移植性，一般不建议直接使用这些类型，建议使用<code>int8_t</code>，<code>int16_t</code>，<code>int32_t</code>等类型。</p>
</blockquote>
<p><strong>(47)内存对齐规则？为什么要内存对齐？</strong></p>
<blockquote>
<p>内存对齐有两个要求，第一，C++中有对齐系数这个概念，任何类型在内存中的首地址必须是自身对齐系数的整数倍，基本类型的对齐系数等于自身大小，结构体类型的内存对齐系数等于内存占用最大的基本类型成员的大小；第二，结构体内类型，相对于结构体首地址的偏移必须等于自身对齐系数的整数倍。引入内存对齐，是为了减少CPU访问内存数据的次数，提高取数据的效率。</p>
</blockquote>
<p><strong>(48)通过指针访问数组，系统是如何知道指针越界的？</strong></p>
<blockquote>
<p>编译器编译代码期间会增加额外的代码用于检测数组是否越界。生成下标越界检查代码，C语言默认关闭；C++默认开启。</p>
</blockquote>
<p><strong>(49)断言是什么？断言和条件语句的优劣？</strong></p>
<blockquote>
<p>断言用于在代码编译或者执行期间检查特定条件是否成立，不成立则报错终止。静态断言和动态断言是两种不同类型的断言。静态断言在代码编译期间进行验证，并在发现问题时引发编译时错误；动态断言在代码运行期间进行验证，并在发现问题时引发异常或错误。C++内，动态断言通常只在<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F&zhida_source=entity">调试模式</a>下启用，而在发布模式下会被忽略。断言相比于条件语句，效率更高，但降低了程序安全性。</p>
</blockquote>
<p><strong>(50)继承和组合的优劣？</strong></p>
<blockquote>
<p>继承和组合都是代码复用的方案，继承的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=227984126&content_type=Article&match_order=1&q=%E8%80%A6%E5%90%88%E6%80%A7&zhida_source=entity">耦合性</a>更高，但提供了更多复用特性，比如<code>public</code>和<code>private</code>复用、比如多态。</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://lightdust02.github.io/2024/01/01/%E7%9F%A5%E8%AF%86%E7%82%B9-C++/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/01/01/Welcome/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Welcome!
          
        </div>
      </a>
    
    
      <a href="/2024/01/01/%E7%9F%A5%E8%AF%86%E7%82%B9-Linux/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">知识点-Linux</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.staticfile.org/valine/1.4.16/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "",
    app_key: "",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2025
        <i class="ri-heart-fill heart_icon"></i> LightDust
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
        <li>
          <a href="http://www.beian.miit.gov.cn/" target="_black" rel="nofollow">浙ICP备88888888</a>
        </li>
        
    </ul>
    <ul>
      
      <li>
          <img src="/images/beian.png"></img>
          <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=01234567890123" target="_black" rel="nofollow">浙公网安备01234567890123号</a>
      </li>
        
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src=''></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="LightDust"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>